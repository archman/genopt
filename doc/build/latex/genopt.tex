% Generated by Sphinx.
\def\sphinxdocclass{report}
\newif\ifsphinxKeepOldNames \sphinxKeepOldNamestrue
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage{iftex}

\ifPDFTeX
  \usepackage[utf8]{inputenc}
\fi
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}
%\documentclass{memoir}
\makeatletter
\fancypagestyle{normal}{
	\fancyhf{}
    \fancyfoot[LE,RO]{{\py@HeaderFamily\thepage}}
    \fancyfoot[LO]{{\py@HeaderFamily\nouppercase{\rightmark}}}
    \fancyfoot[RE]{{\py@HeaderFamily\nouppercase{\leftmark}}}
    \fancyhead[LE,RO]{{\py@HeaderFamily \@title}} % here's the change
    \renewcommand{\headrulewidth}{0.4pt}
    \renewcommand{\footrulewidth}{0.4pt}
}

\makeatother
%\pagecolor [RGB]{255, 247, 226}
\definecolor{VerbatimColor}{rgb}{0.93,0.93,0.92}
%\definecolor{VerbatimColor}{rgb}{0.94,0.85,0.69}
\definecolor{VerbatimBorderColor}{rgb}{0.1,0.3,0.8}
\definecolor{VerbatimBorderColor}{rgb}{0.93,0.93,0.92}

\usepackage[T1]{fontenc}
\usepackage{inconsolata}
%\usepackage{tgschola}
\usepackage{tgpagella}



\title{genopt Documentation}
\date{Feb 06, 2017}
\release{0.1.0}
\author{Tong Zhang}
\newcommand{\sphinxlogo}{\sphinxincludegraphics{frib-logo.png}\par}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vm\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@dl\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@fm\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sa\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


\begin{sphinxShadowBox}
\textbf{genopt Python package}

\medskip


\sphinxcode{genopt}: general multi-dimensional optimization
\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Tong Zhang

\item[{E-mail}] \leavevmode
\href{mailto:zhangt@frib.msu.edu}{zhangt@frib.msu.edu}

\item[{Copyright}] \leavevmode
2016, Facility for Rare Isotope Beams, Michigan State University

\end{description}\end{quote}
\end{sphinxShadowBox}


\chapter{Introduction}
\label{src/intro:introduction}\label{src/intro::doc}\label{src/intro:welcome-to-genopt-s-documentation}
\sphinxcode{genopt} is a python package, trying to serve as a solution of general
multi-dimensional optimization. The core optimization algorithms employed
inside are mainly provided by \sphinxcode{DAKOTA}, which is the brief for
\emph{Design Analysis Kit for Optimization and Terascale Applications},
another tool written in C++.

The following image illustrates the general optimization framework
by properly utilizing \sphinxcode{DAKOTA}.

\noindent{\hspace*{\fill}\sphinxincludegraphics{{dakota-sys-workflow_2}.png}\hspace*{\fill}}

To apply this optimization framework, specific \sphinxcode{analysis drivers} should
be created first, e.g. \sphinxcode{flamedriver1}, \sphinxcode{flamedriver2}... indicate the
dedicated executable drivers built from C++, for the application in
accelerator commissioning, e.g. FRIB.

\noindent{\hspace*{\fill}\sphinxincludegraphics{{dakota-genopt-framework}.png}\hspace*{\fill}}

\begin{notice}{note}{Note:}
\sphinxcode{flame} is an particle envolope tracking code developed by C++,
with the capbility of multi-charge particle states momentum space
tracking, it is developed by FRIB; \sphinxcode{flamedriver(s)} are
user-customized executables by linking the flame core library
(\sphinxcode{libflame\_core.so}) to accomplish various different requirements.
\end{notice}

The intention of \sphinxcode{genopt} is to provide a uniform interface to do the
multi-dimensional optimization tasks. It provides interfaces to let the
users to customize the optimization drivers, optimization methods,
variables, etc. The optimized results are returned by clean interface.
Dedicated analysis drivers should be created and tell the package to use.
\sphinxcode{DakotaOC} is a dedicated class designed for orbit correction for
accelerator, which uses \sphinxcode{flame} as the modeling tool.


\chapter{Demonstrations}
\label{src/demos::doc}\label{src/demos:demonstrations}
Here goes some examples to use \sphinxcode{genopt} package to do orbit correction,
it should be noted that the more complicated the script is,
the more options could be adjusted to fulfill specific goals.


\section{Getting started}
\label{src/demos/demo1:getting-started}\label{src/demos/demo1::doc}\label{src/demos/demo1:simplest-approach}
This approach requires fewest input of code to complete the orbit
correction optimization task, which also means you only has very few
options to adjust to the optimization model. Hopefully, this approach
could be used as an ordinary template to fulfill most of the orbit
correction tasks. Below is the demo code:

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kn}{import} \PYG{n+nn}{genopt}

\PYG{n}{latfile} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test\PYGZus{}392.lat}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{oc\PYGZus{}ins} \PYG{o}{=} \PYG{n}{genopt}\PYG{o}{.}\PYG{n}{DakotaOC}\PYG{p}{(}\PYG{n}{lat\PYGZus{}file}\PYG{o}{=}\PYG{n}{latfile}\PYG{p}{)}

\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{simple\PYGZus{}run}\PYG{p}{(}\PYG{n}{method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mpi}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{np}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{iternum}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} get output}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{get\PYGZus{}orbit}\PYG{p}{(}\PYG{n}{outfile}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{orbit.dat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

The lattice file used here could be found from
\sphinxcode{here}, or from \url{https://github.com/archman/genopt/blob/master/lattice/test\_392.lat}.

For this approach, the following default configuration is applied:
\begin{enumerate}
\item {} 
Selected all BPMs and correctors (both horizontal and vertical types);

\item {} 
Set the reference orbit with all BPMs' readings of \sphinxcode{x=0} and \sphinxcode{y=0};

\item {} 
Set the objective function with the sum of all the square of orbit deviations w.r.t. reference orbit.

\end{enumerate}

By default, \sphinxcode{conmin\_frcg} optimization method is used, possible options
for \sphinxcode{simple\_run()} could be:
\begin{itemize}
\item {} \begin{description}
\item[{common options:}] \leavevmode\begin{enumerate}
\item {} 
\sphinxcode{mpi}: if True, run in parallel mode; if False, run in serial mode;

\item {} 
\sphinxcode{np}: number of cores to use if \sphinxcode{mpi} is True;

\item {} 
\sphinxcode{echo}: if False, will not generate output when optimizing, the same for \sphinxcode{run()};

\end{enumerate}

\end{description}

\item {} \begin{description}
\item[{gradient descent, i.e. \sphinxcode{method=cg}:}] \leavevmode\begin{enumerate}
\item {} 
\sphinxcode{iternum}: max iteration number, 20 by default;

\item {} 
\sphinxcode{step}: forward gradient step size, 1e-6 by default;

\end{enumerate}

\end{description}

\item {} \begin{description}
\item[{pattern search, i.e. \sphinxcode{method=ps}:}] \leavevmode\begin{enumerate}
\item {} 
\sphinxcode{iternum}: max iteration number, 20 by default;

\item {} 
\sphinxcode{evalnum}: max function evaulation number, 1000 by default;

\end{enumerate}

\end{description}

\end{itemize}

There are two options for \sphinxcode{DakotaOC} maybe useful sometimes:
\begin{enumerate}
\item {} 
\sphinxcode{workdir}: root directory for dakota input and output files

\item {} 
\sphinxcode{keep}: if keep working files, True or False

\end{enumerate}

After run this script, beam orbit data could be saved into file, e.g.
\sphinxcode{orbit.dat}:

which could be used to generate figures, the following figure is a typical
one could be generated from the optimized results:

\noindent{\hspace*{\fill}\sphinxincludegraphics{{oc_x0y0}.png}\hspace*{\fill}}


\section{Setup BPMs, correctors and reference orbit}
\label{src/demos/demo2:setup-bpms-correctors-and-reference-orbit}\label{src/demos/demo2::doc}
For more general cases, \sphinxcode{genopt} provides interfaces to setup
BPMs, correctors, reference orbit and objective function type, etc.,
leaving more controls to the user side, to fulfill specific task.

Here is an exmaple to show how to use these capabilities.

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kn}{import} \PYG{n+nn}{genopt}

\PYG{c+c1}{\PYGZsh{} lattice file}
\PYG{n}{latfile} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test\PYGZus{}392.lat}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{oc\PYGZus{}ins} \PYG{o}{=} \PYG{n}{genopt}\PYG{o}{.}\PYG{n}{DakotaOC}\PYG{p}{(}\PYG{n}{lat\PYGZus{}file}\PYG{o}{=}\PYG{n}{latfile}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} select BPMs}
\PYG{n}{bpms} \PYG{o}{=} \PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{get\PYGZus{}elem\PYGZus{}by\PYGZus{}type}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bpm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{set\PYGZus{}bpms}\PYG{p}{(}\PYG{n}{bpm}\PYG{o}{=}\PYG{n}{bpms}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} select correctors}
\PYG{n}{hcors} \PYG{o}{=} \PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{get\PYGZus{}all\PYGZus{}cors}\PYG{p}{(}\PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{40}\PYG{p}{]}
\PYG{n}{vcors} \PYG{o}{=} \PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{get\PYGZus{}all\PYGZus{}cors}\PYG{p}{(}\PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{40}\PYG{p}{]}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{set\PYGZus{}cors}\PYG{p}{(}\PYG{n}{hcor}\PYG{o}{=}\PYG{n}{hcors}\PYG{p}{,} \PYG{n}{vcor}\PYG{o}{=}\PYG{n}{vcors}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} setup objective function type}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{ref\PYGZus{}flag} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{xy}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} setup reference orbit in x and y}
\PYG{n}{bpms\PYGZus{}size} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{bpms}\PYG{p}{)}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{set\PYGZus{}ref\PYGZus{}x0}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{bpms\PYGZus{}size}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{0.0}\PYG{p}{)}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{set\PYGZus{}ref\PYGZus{}y0}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{bpms\PYGZus{}size}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{0.0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} run optimizaiton}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{simple\PYGZus{}run}\PYG{p}{(}\PYG{n}{method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mpi}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{np}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{iternum}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} get output}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{get\PYGZus{}orbit}\PYG{p}{(}\PYG{n}{outfile}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{orbit.dat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{)}

\end{Verbatim}

The highlighted code block is added for controlling all these
abovementioned properties.

\begin{notice}{warning}{Warning:}\begin{enumerate}
\item {} 
BPMs and correctos are distinguished by the element index, which
could be get by proper method, e.g. \sphinxcode{get\_all\_cors()};

\item {} 
The array size of selected BPMs and reference orbit must be the same;

\item {} 
\sphinxcode{bpms}, \sphinxcode{hcors}, \sphinxcode{vcors} are properties of \sphinxcode{DakotaOC} instance.

\end{enumerate}
\end{notice}

\begin{notice}{warning}{Warning:}
All elements could be treated as \sphinxtitleref{BPMs}, see \sphinxcode{set\_bpms()}, set \sphinxcode{pseudo\_all=True}
option will use all elements as monitors.
\end{notice}

\begin{notice}{note}{Note:}
Objective functions could be chosen from three types according to the value
of \sphinxcode{ref\_flag}:
\begin{enumerate}
\item {} 
\sphinxcode{ref\_flag="xy"}: \(\sum \Delta x^2 + \sum \Delta y^2\)

\item {} 
\sphinxcode{ref\_flag="x"}: \(\sum \Delta x^2\)

\item {} 
\sphinxcode{ref\_flag="y"}: \(\sum \Delta y^2\)

\end{enumerate}

where \(\Delta x = x - x_0\), \(\Delta y = y - y_0\).
\end{notice}


\section{Setup variables}
\label{src/demos/demo3:setup-variables}\label{src/demos/demo3::doc}
By default the variables to be optimized is setup with the following
parameters:

\noindent\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
initial value
\unskip}\relax &\textsf{\relax 
lower bound
\unskip}\relax &\textsf{\relax 
upper bound
\unskip}\relax \\
\hline
1e-4
&
-0.01
&
0.01
\\
\hline\end{tabulary}


However, subtle configuration could be achieved by using \sphinxcode{set\_variables()}
method of \sphinxcode{DakotaOc} class, here is how to do it:

Parameter could be created by using \sphinxcode{DakotaParam} class, here is the code:

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{\PYGZsh{} set x correctors}
\PYG{n}{hcors} \PYG{o}{=} \PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{get\PYGZus{}all\PYGZus{}cors}\PYG{p}{(}\PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{40}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} set initial, lower, upper values for each variables}
\PYG{n}{n\PYGZus{}h} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{hcors}\PYG{p}{)}
\PYG{n}{xinit\PYGZus{}vals} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{n}{size}\PYG{o}{=}\PYG{n}{n\PYGZus{}h}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mf}{1.0e\PYGZhy{}4}
\PYG{n}{xlower\PYGZus{}vals} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{n\PYGZus{}h}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.01}\PYG{p}{)}
\PYG{n}{xupper\PYGZus{}vals} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{n\PYGZus{}h}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mf}{0.01}
\PYG{n}{xlbls} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X\PYGZob{}0:03d\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n\PYGZus{}h}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} create parameters}
\PYG{n}{plist\PYGZus{}x} \PYG{o}{=} \PYG{p}{[}\PYG{n}{genopt}\PYG{o}{.}\PYG{n}{DakotaParam}\PYG{p}{(}\PYG{n}{lbl}\PYG{p}{,} \PYG{n}{val\PYGZus{}i}\PYG{p}{,} \PYG{n}{val\PYGZus{}l}\PYG{p}{,} \PYG{n}{val\PYGZus{}u}\PYG{p}{)} 
            \PYG{k}{for} \PYG{p}{(}\PYG{n}{lbl}\PYG{p}{,} \PYG{n}{val\PYGZus{}i}\PYG{p}{,} \PYG{n}{val\PYGZus{}l}\PYG{p}{,} \PYG{n}{val\PYGZus{}u}\PYG{p}{)} \PYG{o+ow}{in} 
                \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{xlbls}\PYG{p}{,} \PYG{n}{xinit\PYGZus{}vals}\PYG{p}{,} \PYG{n}{xlower\PYGZus{}vals}\PYG{p}{,} \PYG{n}{xupper\PYGZus{}vals}\PYG{p}{)}\PYG{p}{]}
\end{Verbatim}

\sphinxcode{plist\_y} could be created in the same way, then issue \sphinxcode{set\_variables()}
with \sphinxcode{set\_variables(plist=plist\_x+plist\_y)}.

\begin{notice}{note}{Note:}
The emphasized line is to setup the variable labels, it is recommended
that all parameters' label with the format like \sphinxcode{x001}, \sphinxcode{x002}, etc.
\end{notice}


\section{Setup optimization engine}
\label{src/demos/demo4::doc}\label{src/demos/demo4:setup-optimization-engine}
The simplest approach, (see {\hyperref[src/demos/demo1:simplest\string-approach]{\sphinxcrossref{\DUrole{std,std-ref}{Getting started}}}}), just covers detail
of the more specific configurations, especially for the optimization engine
itself, however \sphinxcode{genopt} provides different interfaces to make customized
adjustment.


\subsection{Method}
\label{src/demos/demo4:method}
\sphinxcode{DakotaMethod} is designed to handle \sphinxcode{method} block, which is essential
to define the optimization method, e.g.

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{oc\PYGZus{}method} \PYG{o}{=} \PYG{n}{genopt}\PYG{o}{.}\PYG{n}{DakotaMethod}\PYG{p}{(}\PYG{n}{method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ps}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{max\PYGZus{}iterations}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{,}
            \PYG{n}{contraction\PYGZus{}factor}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} other options could be added, like max\PYGZus{}function\PYGZus{}evaluations=2000}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{set\PYGZus{}method}\PYG{p}{(}\PYG{n}{oc\PYGZus{}method}\PYG{p}{)}
\end{Verbatim}


\subsection{Interface}
\label{src/demos/demo4:interface}
\sphinxcode{DakotaInterface} is designed to handle \sphinxcode{interface} block, for the
general optimization regime, \sphinxcode{fork} mode is the common case, only if
the analysis driver is compile into dakota, \sphinxcode{direct} could be used.

Here is an example of user-defined interface:

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{bpms} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{30}\PYG{p}{]}
\PYG{n}{hcors}\PYG{p}{,} \PYG{n}{vcors} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{]}
\PYG{n}{latfile} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test.lat}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{oc\PYGZus{}inter} \PYG{o}{=} \PYG{n}{genopt}\PYG{o}{.}\PYG{n}{DakotaInterface}\PYG{p}{(}\PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fork}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                    \PYG{n}{driver}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{flamedriver\PYGZus{}oc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                    \PYG{n}{latfile}\PYG{o}{=}\PYG{n}{latfile}\PYG{p}{,}
                    \PYG{n}{bpms}\PYG{o}{=}\PYG{n}{bpms}\PYG{p}{,} \PYG{n}{hcors}\PYG{o}{=}\PYG{n}{hcors}\PYG{p}{,} \PYG{n}{vcors}\PYG{o}{=}\PYG{n}{vcors}\PYG{p}{,}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} set interface}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{set\PYGZus{}interface}\PYG{p}{(}\PYG{n}{oc\PYGZus{}inter}\PYG{p}{)}
\end{Verbatim}

\begin{notice}{note}{Note:}
Extra parameters could be added by this way:
oc\_inter.set\_extra(deactivate=''active\_set\_vector'')
\end{notice}


\subsection{Responses}
\label{src/demos/demo4:responses}
Objective function(s) and gradients/hessians could be set in
\sphinxcode{responses} block, which is handled by \sphinxcode{DakotaResponses} class.

Typical example:

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{oc\PYGZus{}responses} \PYG{o}{=} \PYG{n}{DakotaResponses}\PYG{p}{(}\PYG{n}{gradient}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{numerical}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{step}\PYG{o}{=}\PYG{l+m+mf}{2.0e\PYGZhy{}7}\PYG{p}{)}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{set\PYGZus{}responses}\PYG{p}{(}\PYG{n}{oc\PYGZus{}responses}\PYG{p}{)}
\end{Verbatim}


\subsection{Environment}
\label{src/demos/demo4:environment}
Dakota environment block could be adjusted by instantiating class
\sphinxcode{DakotaEnviron}, e.g.

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{datfile} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dakota1.dat}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{e} \PYG{o}{=} \PYG{n}{genopt}\PYG{o}{.}\PYG{n}{DakotaEnviron}\PYG{p}{(}\PYG{n}{tabfile}\PYG{o}{=}\PYG{n}{datfile}\PYG{p}{)}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{set\PYGZus{}environ}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)}
\end{Verbatim}

\sphinxcode{tabfile} option could be used to define where the dakota tabular data
should go, will not generate tabular file if not set.


\subsection{Model}
\label{src/demos/demo4:model}
\sphinxcode{DakotaModel} is designed to handle \sphinxcode{model} block, recently, just use
the default configuration, i.e:

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{set\PYGZus{}model}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} or:}
\PYG{n}{m} \PYG{o}{=} \PYG{n}{genopt}\PYG{o}{.}\PYG{n}{DakotaModel}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{set\PYGZus{}model}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}
\end{Verbatim}


\section{Run optimization}
\label{src/demos/demo5::doc}\label{src/demos/demo5:run-optimization}
If running optimization not by \sphinxcode{simple\_run()} method, another approach
should be utilized.

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{\PYGZsh{} generate input file for optimization}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{gen\PYGZus{}dakota\PYGZus{}input}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} run optimization}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{mpi}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{np}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}
\end{Verbatim}

Below is a typical user customized script to find the optimized correctors
configurations.

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{import} \PYG{n+nn}{genopt}

\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} orbit correction demo}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{n}{latfile} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test\PYGZus{}392.lat}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{oc\PYGZus{}ins} \PYG{o}{=} \PYG{n}{genopt}\PYG{o}{.}\PYG{n}{DakotaOC}\PYG{p}{(}\PYG{n}{lat\PYGZus{}file}\PYG{o}{=}\PYG{n}{latfile}\PYG{p}{,} 
                         \PYG{n}{workdir}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./oc\PYGZus{}tmp4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
                         \PYG{n}{keep}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set BPMs and correctors}
\PYG{n}{bpms} \PYG{o}{=} \PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{get\PYGZus{}elem\PYGZus{}by\PYGZus{}type}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bpm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{hcors} \PYG{o}{=} \PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{get\PYGZus{}all\PYGZus{}cors}\PYG{p}{(}\PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{40}\PYG{p}{]}
\PYG{n}{vcors} \PYG{o}{=} \PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{get\PYGZus{}all\PYGZus{}cors}\PYG{p}{(}\PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{40}\PYG{p}{]}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{set\PYGZus{}bpms}\PYG{p}{(}\PYG{n}{bpm}\PYG{o}{=}\PYG{n}{bpms}\PYG{p}{)}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{set\PYGZus{}cors}\PYG{p}{(}\PYG{n}{hcor}\PYG{o}{=}\PYG{n}{hcors}\PYG{p}{,} \PYG{n}{vcor}\PYG{o}{=}\PYG{n}{vcors}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set parameters}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{set\PYGZus{}variables}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set interface}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{set\PYGZus{}interface}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set responses}
\PYG{n}{r} \PYG{o}{=} \PYG{n}{genopt}\PYG{o}{.}\PYG{n}{DakotaResponses}\PYG{p}{(}\PYG{n}{gradient}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{numerical}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{step}\PYG{o}{=}\PYG{l+m+mf}{2.0e\PYGZhy{}5}\PYG{p}{)}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{set\PYGZus{}responses}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set model}
\PYG{n}{m} \PYG{o}{=} \PYG{n}{genopt}\PYG{o}{.}\PYG{n}{DakotaModel}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{set\PYGZus{}model}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set method}
\PYG{n}{md} \PYG{o}{=} \PYG{n}{genoptDakotaMethod}\PYG{p}{(}\PYG{n}{method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ps}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
        \PYG{n}{max\PYGZus{}function\PYGZus{}evaluations}\PYG{o}{=}\PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{set\PYGZus{}method}\PYG{p}{(}\PYG{n}{method}\PYG{o}{=}\PYG{n}{md}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set environment}
\PYG{n}{tabfile} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{abspath}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./oc\PYGZus{}tmp4/dakota1.dat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{e} \PYG{o}{=} \PYG{n}{genopt}\PYG{o}{.}\PYG{n}{dakutils}\PYG{o}{.}\PYG{n}{DakotaEnviron}\PYG{p}{(}\PYG{n}{tabfile}\PYG{o}{=}\PYG{n}{tabfile}\PYG{p}{)}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{set\PYGZus{}environ}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set reference orbit}
\PYG{n}{bpms\PYGZus{}size} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{bpms}\PYG{p}{)}
\PYG{n}{ref\PYGZus{}x0} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{bpms\PYGZus{}size}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{0.0}
\PYG{n}{ref\PYGZus{}y0} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{bpms\PYGZus{}size}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{0.0}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{set\PYGZus{}ref\PYGZus{}x0}\PYG{p}{(}\PYG{n}{ref\PYGZus{}x0}\PYG{p}{)}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{set\PYGZus{}ref\PYGZus{}y0}\PYG{p}{(}\PYG{n}{ref\PYGZus{}y0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set objective function}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{ref\PYGZus{}flag} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{xy}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} generate input}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{gen\PYGZus{}dakota\PYGZus{}input}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} run}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{mpi}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{np}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}print oc\PYGZus{}ins.get\PYGZus{}opt\PYGZus{}results()}

\PYG{c+c1}{\PYGZsh{} get output}
\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{get\PYGZus{}orbit}\PYG{p}{(}\PYG{p}{(}\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{hcor}\PYG{p}{,} \PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{vcor}\PYG{p}{)}\PYG{p}{,} \PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{get\PYGZus{}opt\PYGZus{}results}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} 
                  \PYG{n}{outfile}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{orbit.dat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot}
\PYG{c+c1}{\PYGZsh{}oc\PYGZus{}ins.plot()}
\end{Verbatim}

The following figure shows correct the orbit to different reference orbits.

\noindent{\hspace*{\fill}\sphinxincludegraphics{{oc_015}.png}\hspace*{\fill}}


\section{After optimization}
\label{src/demos/demo6::doc}\label{src/demos/demo6:after-optimization}
Suppose all the optimized results have been generated, here are the
possible post-operations:
\begin{enumerate}
\item {} 
Operations on the optimized \sphinxcode{Machine} object;

\item {} 
Generate new lattice file with optimized results for other programs.

\end{enumerate}

\textbf{Optimization snippet:}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{latfile} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test\PYGZus{}392.lat}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{oc} \PYG{o}{=} \PYG{n}{genopt}\PYG{o}{.}\PYG{n}{DakotaOC}\PYG{p}{(}\PYG{n}{lat\PYGZus{}file}\PYG{o}{=}\PYG{n}{latfile}\PYG{p}{)}
\PYG{n}{oc}\PYG{o}{.}\PYG{n}{simple\PYGZus{}run}\PYG{p}{(}\PYG{n}{iternum}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)}
\end{Verbatim}


\subsection{Get optimized results}
\label{src/demos/demo6:get-optimized-results}
Optimized results could be retrieved by \sphinxcode{get\_opt\_results()} method of
\sphinxcode{DakotaOC} class:
\begin{itemize}
\item {} 
return type: list

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{r} \PYG{o}{=} \PYG{n}{oc}\PYG{o}{.}\PYG{n}{get\PYGZus{}opt\PYGZus{}results}\PYG{p}{(}\PYG{n}{rtype}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{list}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}
\PYG{g+go}{[0.00013981587907,}
\PYG{g+go}{ 7.5578423135e\PYGZhy{}05,}
\PYG{g+go}{ \PYGZhy{}5.3982438406e\PYGZhy{}05,}
\PYG{g+go}{ \PYGZhy{}1.9620020032e\PYGZhy{}06,}
\PYG{g+go}{ 0.00017942079806,}
\PYG{g+go}{ ...}
\PYG{g+go}{ 2.0182502319e\PYGZhy{}05,}
\PYG{g+go}{ 0.0001173634281,}
\PYG{g+go}{ 8.685656753e\PYGZhy{}05,}
\PYG{g+go}{ 7.3950720611e\PYGZhy{}05,}
\PYG{g+go}{ 8.2924283647e\PYGZhy{}05]}
\end{Verbatim}

The returned list is alphabetically sorted according to the
variables' names.
\begin{itemize}
\item {} 
return type: dictionary, label format: \sphinxcode{plain}

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{r} \PYG{o}{=} \PYG{n}{oc}\PYG{o}{.}\PYG{n}{get\PYGZus{}opt\PYGZus{}results}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} or}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{r} \PYG{o}{=} \PYG{n}{oc}\PYG{o}{.}\PYG{n}{get\PYGZus{}opt\PYGZus{}results}\PYG{p}{(}\PYG{n}{rtype}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dict}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{plain}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}x001\PYGZsq{}: 0.00013981587907,}
\PYG{g+go}{ \PYGZsq{}x002\PYGZsq{}: 7.5578423135e\PYGZhy{}05,}
\PYG{g+go}{ \PYGZsq{}x003\PYGZsq{}: \PYGZhy{}5.3982438406e\PYGZhy{}05,}
\PYG{g+go}{ \PYGZsq{}x004\PYGZsq{}: \PYGZhy{}1.9620020032e\PYGZhy{}06,}
\PYG{g+go}{ \PYGZsq{}x005\PYGZsq{}: 0.00017942079806,}
\PYG{g+go}{ ...}
\PYG{g+go}{ \PYGZsq{}y056\PYGZsq{}: 2.0182502319e\PYGZhy{}05,}
\PYG{g+go}{ \PYGZsq{}y057\PYGZsq{}: 0.0001173634281,}
\PYG{g+go}{ \PYGZsq{}y058\PYGZsq{}: 8.685656753e\PYGZhy{}05,}
\PYG{g+go}{ \PYGZsq{}y059\PYGZsq{}: 7.3950720611e\PYGZhy{}05,}
\PYG{g+go}{ \PYGZsq{}y060\PYGZsq{}: 8.2924283647e\PYGZhy{}05\PYGZcb{}}
\end{Verbatim}
\begin{itemize}
\item {} 
return type: dictionary, label format: \sphinxcode{fancy}

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{r} \PYG{o}{=} \PYG{n}{oc}\PYG{o}{.}\PYG{n}{get\PYGZus{}opt\PYGZus{}results}\PYG{p}{(}\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fancy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}FS1\PYGZus{}BBS:DCH\PYGZus{}D2412\PYGZsq{}: \PYGZob{}\PYGZsq{}config\PYGZsq{}: \PYGZob{}\PYGZsq{}theta\PYGZus{}x\PYGZsq{}: 0.00021066533055\PYGZcb{}, \PYGZsq{}id\PYGZsq{}: 1048\PYGZcb{},}
\PYG{g+go}{ \PYGZsq{}FS1\PYGZus{}BBS:DCH\PYGZus{}D2476\PYGZsq{}: \PYGZob{}\PYGZsq{}config\PYGZsq{}: \PYGZob{}\PYGZsq{}theta\PYGZus{}x\PYGZsq{}: 0.00025833402592\PYGZcb{}, \PYGZsq{}id\PYGZsq{}: 1098\PYGZcb{},}
\PYG{g+go}{ ...}
\end{Verbatim}

This is the more comprehensive way to represent the results, one of the
advantages is that results with this format could be easily to apply on to
\sphinxcode{reconfigure} method of \sphinxcode{Machine} object, for instance:

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{r}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{m}\PYG{o}{.}\PYG{n}{reconfigure}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{id}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{v}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{config}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{notice}{note}{Note:}
\sphinxcode{get\_opt\_results} has \sphinxcode{outfile} optional parameter, if not
defined, output file that generated by current optimization
instance would be used, or the defined dakota output file would be used,
but only valid for cases of \sphinxcode{label='plain'};
\sphinxcode{label='fancy'} is only valid for
the case of \sphinxcode{rtype='dict'}.
\end{notice}


\subsection{Get orbit data}
\label{src/demos/demo6:get-orbit-data}
\sphinxcode{get\_orbit()} could be used to apply all the optimized results, then
new \sphinxcode{Machine} could be get in the following way:

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{z}\PYG{p}{,}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{m} \PYG{o}{=} \PYG{n}{oc}\PYG{o}{.}\PYG{n}{get\PYGZus{}orbit}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{m}\PYG{o}{.}\PYG{n}{conf}\PYG{p}{(}\PYG{l+m+mi}{1224}\PYG{p}{)}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{theta\PYGZus{}x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{8.5216269467e\PYGZhy{}05}
\end{Verbatim}

Or in another way:

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc}\PYG{o}{.}\PYG{n}{get\PYGZus{}orbit}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{m} \PYG{o}{=} \PYG{n}{oc}\PYG{o}{.}\PYG{n}{get\PYGZus{}machine}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

New machine \sphinxcode{m} could be used for the next operations.

\begin{notice}{note}{Note:}
\sphinxcode{get\_orbit()}  could be assigned a optional parameter: \sphinxcode{outfile},
into which the plain ASCII data of \sphinxcode{zpos}, \sphinxcode{x}, and \sphinxcode{y} would
be saved.
\end{notice}


\subsection{Get new optimized lattice file}
\label{src/demos/demo6:get-new-optimized-lattice-file}
\sphinxcode{get\_opt\_latfile()} is created to generate new lattice file with
optimized results, for the sake of possible next usage of asking for
lattice file, this is kind of more general interface.

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc}\PYG{o}{.}\PYG{n}{get\PYGZus{}opt\PYGZus{}latfile}\PYG{p}{(}\PYG{n}{outfile}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{opt1.lat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

Here is the links to the lattice files of
\sphinxcode{original} and
\sphinxcode{optimized} ones, both could be
used as the input lattice file of \sphinxcode{flame} program.

\begin{notice}{note}{Note:}
{\hyperref[src/apidocs/dakutils:genopt.dakutils.generate_latfile]{\sphinxcrossref{\sphinxcode{generate\_latfile()}}}}
in module \sphinxcode{genopt.dakutils}
could be used to generate lattice file from \sphinxcode{flame.Machine} object.
\end{notice}


\chapter{API}
\label{src/apidoc:api}\label{src/apidoc::doc}

\section{genopt package}
\label{src/apidocs/genopt:genopt-package}\label{src/apidocs/genopt::doc}\label{src/apidocs/genopt:module-genopt}\index{genopt (module)}
General multi-dimensional optimization package built by Python,
incorporating optimization algorithms provided by DAKOTA.
\begin{quote}\begin{description}
\item[{version}] \leavevmode
0.1.0+3.g19de011

\item[{author}] \leavevmode
Tong Zhang \textless{}\href{mailto:zhangt@frib.msu.edu}{zhangt@frib.msu.edu}\textgreater{}

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} This is a ordinary example to do orbit correction by }
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} multi\PYGZhy{}dimensional optimization approach.}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} } 
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} import package}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{genopt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} lattice file name}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{latfile} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./contrib/test\PYGZus{}392.lat}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} create optimization object}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}ins} \PYG{o}{=} \PYG{n}{genopt}\PYG{o}{.}\PYG{n}{DakotaOC}\PYG{p}{(}\PYG{n}{lat\PYGZus{}file}\PYG{o}{=}\PYG{n}{latfile}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} get indices of BPMs and correctors}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{bpms} \PYG{o}{=} \PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{get\PYGZus{}elem\PYGZus{}by\PYGZus{}type}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bpm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cors} \PYG{o}{=} \PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{get\PYGZus{}all\PYGZus{}cors}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{45}\PYG{p}{:}\PYG{l+m+mi}{61}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} set BPMs and correctors}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{set\PYGZus{}bpms}\PYG{p}{(}\PYG{n}{bpm}\PYG{o}{=}\PYG{n}{bpms}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{set\PYGZus{}cors}\PYG{p}{(}\PYG{n}{cor}\PYG{o}{=}\PYG{n}{cors}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} run optimization, enable MPI, }
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} with optimization of CG, 20 iterations}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{simple\PYGZus{}run}\PYG{p}{(}\PYG{n}{method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mpi}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{np}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{iternum}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} get optimized results:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt\PYGZus{}vars} \PYG{o}{=} \PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{get\PYGZus{}opt\PYGZus{}results}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} or show orbit after correction}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} or save the orbit data (to file)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}ins}\PYG{o}{.}\PYG{n}{get\PYGZus{}orbit}\PYG{p}{(}\PYG{n}{outfile}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{orbit.dat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\end{Verbatim}
\index{DakotaInput (class in genopt)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaInput}\pysiglinewithargsret{\sphinxstrong{class }\sphinxbfcode{DakotaInput}}{\emph{**kws}}{}
Bases: \href{https://docs.python.org/2/library/functions.html\#object}{\sphinxcode{object}}

template of dakota input file, field could be overriden by
providing additional keyword arguments,
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{kws}} -- keyword arguments, valid keys are dakota directives

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dak\PYGZus{}inp} \PYG{o}{=} \PYG{n}{DakotaInput}\PYG{p}{(}\PYG{n}{method}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max\PYGZus{}iterations = 500}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{g+go}{                                  \PYGZdq{}convergence\PYGZus{}tolerance = 1e\PYGZhy{}7\PYGZdq{},}
\PYG{g+go}{                                  \PYGZdq{}conmin\PYGZus{}frcg\PYGZdq{},])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\end{Verbatim}
\index{set\_template() (DakotaInput method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaInput.set_template}\pysiglinewithargsret{\sphinxbfcode{set\_template}}{\emph{name='oc'}}{}
\end{fulllineitems}

\index{write() (DakotaInput method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaInput.write}\pysiglinewithargsret{\sphinxbfcode{write}}{\emph{infile=None}}{}
write all the input into file, as dakota input file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{infile}} -- fullname of input file, if not defined, infile will
be assigned as `dakota.in' in current working directory

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{DakotaParam (class in genopt)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaParam}\pysiglinewithargsret{\sphinxstrong{class }\sphinxbfcode{DakotaParam}}{\emph{label}, \emph{initial=0.0}, \emph{lower=-10000000000.0}, \emph{upper=10000000000.0}}{}
Bases: \href{https://docs.python.org/2/library/functions.html\#object}{\sphinxcode{object}}

create dakota variable for \sphinxcode{variables} block
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{label}} -- string to represent itself, e.g. \sphinxcode{x001},
it is recommended to annotate the number with the format of \sphinxcode{\%03d},
i.e. \sphinxcode{1 -{-}\textgreater{} 001}, \sphinxcode{10 -{-}\textgreater{} 010}, \sphinxcode{100 -{-}\textgreater{} 100}, etc.

\item {} 
\textbf{\texttt{initial}} -- initial value, 0.0 by default

\item {} 
\textbf{\texttt{lower}} -- lower bound, -1.0e10 by default

\item {} 
\textbf{\texttt{upper}} -- upper bound, 1.0e10 by default

\end{itemize}

\end{description}\end{quote}
\index{initial (DakotaParam attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaParam.initial}\pysigline{\sphinxbfcode{initial}}
\end{fulllineitems}

\index{label (DakotaParam attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaParam.label}\pysigline{\sphinxbfcode{label}}
\end{fulllineitems}

\index{lower (DakotaParam attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaParam.lower}\pysigline{\sphinxbfcode{lower}}
\end{fulllineitems}

\index{upper (DakotaParam attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaParam.upper}\pysigline{\sphinxbfcode{upper}}
\end{fulllineitems}


\end{fulllineitems}

\index{DakotaBase (class in genopt)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaBase}\pysiglinewithargsret{\sphinxstrong{class }\sphinxbfcode{DakotaBase}}{\emph{**kws}}{}
Bases: \href{https://docs.python.org/2/library/functions.html\#object}{\sphinxcode{object}}

Base class for general optimization, initialized parameters:
valid keyword parameters:
\begin{itemize}
\item {} 
workdir: root dir for dakota input/output files,
the defualt one should be created in /tmp, or define some dir path

\item {} 
dakexec: full path of dakota executable,
the default one should be \emph{dakota}, or define the full path

\item {} 
dakhead: prefixed name for input/output files of \emph{dakota}, 
the default one is \emph{dakota}

\item {} 
keep: if keep the working directory (i.e. defined by \emph{workdir}), default is False

\end{itemize}
\index{dakexec (DakotaBase attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaBase.dakexec}\pysigline{\sphinxbfcode{dakexec}}
\end{fulllineitems}

\index{dakhead (DakotaBase attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaBase.dakhead}\pysigline{\sphinxbfcode{dakhead}}
\end{fulllineitems}

\index{keep (DakotaBase attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaBase.keep}\pysigline{\sphinxbfcode{keep}}
\end{fulllineitems}

\index{workdir (DakotaBase attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaBase.workdir}\pysigline{\sphinxbfcode{workdir}}
\end{fulllineitems}


\end{fulllineitems}

\index{DakotaOC (class in genopt)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC}\pysiglinewithargsret{\sphinxstrong{class }\sphinxbfcode{DakotaOC}}{\emph{lat\_file=None}, \emph{elem\_bpm=None}, \emph{elem\_cor=None}, \emph{elem\_hcor=None}, \emph{elem\_vcor=None}, \emph{ref\_x0=None}, \emph{ref\_y0=None}, \emph{ref\_flag=None}, \emph{model=None}, \emph{optdriver=None}, \emph{**kws}}{}
Bases: {\hyperref[src/apidocs/dakopt:genopt.dakopt.DakotaBase]{\sphinxcrossref{\sphinxcode{genopt.dakopt.DakotaBase}}}}

Dakota optimization class with orbit correction driver
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{lat\_file}} -- lattice file

\item {} 
\textbf{\texttt{elem\_bpm}} -- list of element indice of BPMs

\item {} 
\textbf{\texttt{elem\_cor}} -- list of element indice of correctors, always folders of 2

\item {} 
\textbf{\texttt{elem\_hcor}} -- list of element indice of horizontal correctors

\item {} 
\textbf{\texttt{elem\_vcor}} -- list of element indice of vertical correctors

\item {} 
\textbf{\texttt{ref\_x0}} -- reference orbit in x, list of BPM readings

\item {} 
\textbf{\texttt{ref\_y0}} -- reference orbit in y, list of BPM readings

\item {} 
\textbf{\texttt{ref\_flag}} -- 
string flag for objective functions:
\begin{enumerate}
\item {} 
``x'': \(\sum \Delta x^2\), \(\Delta x = x-x_0\);

\item {} 
``y'': \(\sum \Delta y^2\), \(\Delta y = y-y_0\);

\item {} 
``xy'': \(\sum \Delta x^2 + \sum \Delta y^2\).

\end{enumerate}


\item {} 
\textbf{\texttt{model}} -- simulation model, `flame' or `impact'

\item {} 
\textbf{\texttt{optdriver}} -- analysis driver for optimization, `flamedriver\_oc' by default

\item {} 
\textbf{\texttt{kws}} -- \begin{description}
\item[{keywords parameters for additional usage, defined in \sphinxcode{DakotaBase} class}] \leavevmode
valid keys:

\end{description}
\begin{itemize}
\item {} 
\emph{workdir}: root dir for dakota input/output files,
the defualt one should be created in /tmp, or define some dir path

\item {} 
\emph{dakexec}: full path of dakota executable,
the default one should be \emph{dakota}, or define the full path

\item {} 
\emph{dakhead}: prefixed name for input/output files of \emph{dakota}, 
the default one is \emph{dakota}

\item {} 
\emph{keep}: if keep the working directory (i.e. defined by \emph{workdir}), 
default is False

\end{itemize}


\end{itemize}

\end{description}\end{quote}

\begin{notice}{note}{Note:}
\sphinxcode{elem\_bpm} should be treated as index of elemnt with type name of `BPM',
however, for the simulation convenience, any element is acceptable, see {\hyperref[src/apidocs/genopt:genopt.DakotaOC.set_bpms]{\sphinxcrossref{\sphinxcode{set\_bpms()}}}}.
\end{notice}
\index{bpms (DakotaOC attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.bpms}\pysigline{\sphinxbfcode{bpms}}
\end{fulllineitems}

\index{create\_machine() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.create_machine}\pysiglinewithargsret{\sphinxbfcode{create\_machine}}{\emph{lat\_file}}{}
create machine instance with model configuration
\begin{itemize}
\item {} 
setup \_machine

\item {} 
setup \_elem\_bpm, \_elem\_cor or (\_elem\_hcor and \_elem\_vcor)

\end{itemize}

\end{fulllineitems}

\index{gen\_dakota\_input() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.gen_dakota_input}\pysiglinewithargsret{\sphinxbfcode{gen\_dakota\_input}}{\emph{infile=None}, \emph{debug=False}}{}
generate dakota input file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{infile}} -- dakota input filename

\item {} 
\textbf{\texttt{debug}} -- if True, generate a simple test input file

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_bpms() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.get_all_bpms}\pysiglinewithargsret{\sphinxbfcode{get\_all\_bpms}}{}{}
get list of all valid bpms indices
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
a list of bpm indices

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dakoc} \PYG{o}{=} \PYG{n}{DakotaOC}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test/test.lat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{dakoc}\PYG{o}{.}\PYG{n}{get\PYGZus{}all\PYGZus{}bpms}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{get\_all\_cors() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.get_all_cors}\pysiglinewithargsret{\sphinxbfcode{get\_all\_cors}}{\emph{type=None}}{}
get list of all valid correctors indices
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{type}} -- define corrector type, `h': horizontal, `v': vertical, 
if not defined, return all correctors

\item[{Returns}] \leavevmode
a list of corrector indices

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dakoc} \PYG{o}{=} \PYG{n}{DakotaOC}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test/test.lat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{dakoc}\PYG{o}{.}\PYG{n}{get\PYGZus{}all\PYGZus{}cors}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{get\_all\_elem() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.get_all_elem}\pysiglinewithargsret{\sphinxbfcode{get\_all\_elem}}{}{}
get all elements from \sphinxcode{Machine} object
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
list of element indices

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_elem\_by\_name() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.get_elem_by_name}\pysiglinewithargsret{\sphinxbfcode{get\_elem\_by\_name}}{\emph{name}}{}
get list of element(s) by name(s)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{name}} -- tuple or list of name(s)

\item[{Returns}] \leavevmode
list of element indices

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dakoc} \PYG{o}{=} \PYG{n}{DakotaOC}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test/test.lat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{names} \PYG{o}{=} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LS1\PYGZus{}CA01:BPM\PYGZus{}D1144}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LS1\PYGZus{}WA01:BPM\PYGZus{}D1155}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{idx} \PYG{o}{=} \PYG{n}{dakoc}\PYG{o}{.}\PYG{n}{get\PYGZus{}elem\PYGZus{}by\PYGZus{}name}\PYG{p}{(}\PYG{n}{names}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{idx}\PYG{p}{)}
\PYG{g+go}{[18, 31]}
\end{Verbatim}

\end{fulllineitems}

\index{get\_elem\_by\_type() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.get_elem_by_type}\pysiglinewithargsret{\sphinxbfcode{get\_elem\_by\_type}}{\emph{type}}{}
get list of element(s) by type
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{type}} -- string name of element type

\item[{Returns}] \leavevmode
list of element indices

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dakoc} \PYG{o}{=} \PYG{n}{DakotaOC}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test/test.lat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{type} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bpm}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{idx} \PYG{o}{=} \PYG{n}{dakoc}\PYG{o}{.}\PYG{n}{get\PYGZus{}elem\PYGZus{}by\PYGZus{}type}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{idx}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{get\_machine() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.get_machine}\pysiglinewithargsret{\sphinxbfcode{get\_machine}}{}{}
get flame machine object for potential usage
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
flame machine object or None

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_opt\_latfile() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.get_opt_latfile}\pysiglinewithargsret{\sphinxbfcode{get\_opt\_latfile}}{\emph{outfile='out.lat'}}{}
get optimized lattice file for potential next usage,
\sphinxcode{run()} or \sphinxcode{simple\_run()} should be evoked first to get the 
optimized results.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{outfile}} -- file name for generated lattice file

\item[{Returns}] \leavevmode
lattice file name or None if failed

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_opt\_results() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.get_opt_results}\pysiglinewithargsret{\sphinxbfcode{get\_opt\_results}}{\emph{outfile=None}, \emph{rtype='dict'}, \emph{label='plain'}}{}
extract optimized results from dakota output
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{outfile}} -- file name of dakota output file, 
`dakota.out' by default

\item {} 
\textbf{\texttt{rtype}} -- type of returned results, `dict' or `list', 
`dict' by default

\item {} 
\textbf{\texttt{label}} -- 
label types for returned variables, only valid when rtype `dict', 
`plain' by default:
\begin{itemize}
\item {} 
\emph{`plain'}: variable labels with format of \sphinxcode{x1}, \sphinxcode{x2}, \sphinxcode{y1}, \sphinxcode{y2}, etc.
e.g. \sphinxcode{\{'x1': v1, 'y1': v2\}}

\item {} 
\emph{`fancy'}: variable labels with the name defined in lattice file,
e.g. \sphinxcode{'LS1\_CA01:DCH\_D1131'}, dict returned sample: 
\sphinxcode{\{'LS1\_CA01:DCH\_D1131': \{'id':9, 'config':\{'theta\_x':v1\}\}\}}

\end{itemize}


\end{itemize}

\end{description}\end{quote}

\begin{notice}{note}{Note:}
The \sphinxcode{fancy} option will make re-configuring flame machine in a more 
convenient way, such as:

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt\PYGZus{}cors} \PYG{o}{=} \PYG{n}{get\PYGZus{}opt\PYGZus{}results}\PYG{p}{(}\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fancy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{opt\PYGZus{}cors}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{m}\PYG{o}{.}\PYG{n}{reconfigure}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{id}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{v}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{config}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} here m is an instance of flame.Machine class}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\end{Verbatim}
\end{notice}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
by default return a dict of optimized results with each item
of the format like ``x1'':0.1 or more fancy format by set label with `fancy', etc.,
if rtype='list', return a list of values, when the keys are ascend sorted.

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt\PYGZus{}vars} \PYG{o}{=} \PYG{n}{get\PYGZus{}optresults}\PYG{p}{(}\PYG{n}{outfile}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{flame\PYGZus{}oc.out}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{rtype}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dict}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{opt\PYGZus{}vars}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}x2\PYGZsq{}: 0.0020782814353, \PYGZsq{}x1\PYGZsq{}: \PYGZhy{}0.0017913264033\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt\PYGZus{}vars} \PYG{o}{=} \PYG{n}{get\PYGZus{}optresults}\PYG{p}{(}\PYG{n}{outfile}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{flame\PYGZus{}oc.out}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{rtype}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{list}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{opt\PYGZus{}vars}\PYG{p}{)}
\PYG{g+go}{[\PYGZhy{}0.0017913264033, 0.0020782814353]}
\end{Verbatim}

\end{fulllineitems}

\index{get\_orbit() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.get_orbit}\pysiglinewithargsret{\sphinxbfcode{get\_orbit}}{\emph{idx=None}, \emph{val=None}, \emph{outfile=None}}{}
calculate the orbit with given configurations
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{idx}} -- (idx\_hcor, idx\_vcor), tuple of list of indices of h/v cors

\item {} 
\textbf{\texttt{val}} -- values for each correctos, h/v

\item {} 
\textbf{\texttt{outfile}} -- filename to save the data

\end{itemize}

\item[{Returns}] \leavevmode
tuple of zpos, env\_x, env\_y, machine

\end{description}\end{quote}

\end{fulllineitems}

\index{hcors (DakotaOC attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.hcors}\pysigline{\sphinxbfcode{hcors}}
\end{fulllineitems}

\index{latfile (DakotaOC attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.latfile}\pysigline{\sphinxbfcode{latfile}}
\end{fulllineitems}

\index{optdriver (DakotaOC attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.optdriver}\pysigline{\sphinxbfcode{optdriver}}
\end{fulllineitems}

\index{plot() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.plot}\pysiglinewithargsret{\sphinxbfcode{plot}}{\emph{outfile=None}, \emph{figsize=(10}, \emph{8)}, \emph{dpi=120}, \emph{**kws}}{}
show orbit
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{outfile}} -- output file of dakota

\item {} 
\textbf{\texttt{figsize}} -- figure size, (h, w)

\item {} 
\textbf{\texttt{dpi}} -- figure dpi

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{ref\_flag (DakotaOC attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.ref_flag}\pysigline{\sphinxbfcode{ref\_flag}}
\end{fulllineitems}

\index{ref\_x0 (DakotaOC attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.ref_x0}\pysigline{\sphinxbfcode{ref\_x0}}
\end{fulllineitems}

\index{ref\_y0 (DakotaOC attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.ref_y0}\pysigline{\sphinxbfcode{ref\_y0}}
\end{fulllineitems}

\index{run() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.run}\pysiglinewithargsret{\sphinxbfcode{run}}{\emph{mpi=False}, \emph{np=None}, \emph{echo=True}}{}
run optimization
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{mpi}} -- if True, run DAKOTA in parallel mode, False by default

\item {} 
\textbf{\texttt{np}} -- number of processes to use, only valid when \sphinxcode{mpi} is True

\item {} 
\textbf{\texttt{echo}} -- suppress output if False, True by default

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_bpms() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.set_bpms}\pysiglinewithargsret{\sphinxbfcode{set\_bpms}}{\emph{bpm=None}, \emph{pseudo\_all=False}}{}
set BPMs, and trying to set reference orbit \sphinxcode{(x,y)} if \sphinxcode{x} and \sphinxcode{y}
is of one unique value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{bpm}} -- list of bpm indices, if None, use all BPMs

\item {} 
\textbf{\texttt{pseudo\_all}} -- if set True, will use all elements, ignore \sphinxcode{bpm} parameter

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_cors() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.set_cors}\pysiglinewithargsret{\sphinxbfcode{set\_cors}}{\emph{cor=None}, \emph{hcor=None}, \emph{vcor=None}}{}
set correctors, if cor, hcor and vcor are None, use all correctors
if cor is not None, use cor, ignore hcor and vcor
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{cor}} -- list of corrector indices, hcor, vcor,...

\item {} 
\textbf{\texttt{hcor}} -- list of horizontal corrector indices

\item {} 
\textbf{\texttt{vcor}} -- list of vertical corrector indices

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_environ() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.set_environ}\pysiglinewithargsret{\sphinxbfcode{set\_environ}}{\emph{environ=None}}{}
setup environment block, that is setup \sphinxcode{oc\_environ}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{environ}} -- \sphinxcode{DakotaEnviron} object, automatically setup if not defined

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_interface() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.set_interface}\pysiglinewithargsret{\sphinxbfcode{set\_interface}}{\emph{interface=None}, \emph{**kws}}{}
setup interface block, that is setup \sphinxcode{oc\_interface}
should be ready to invoke after \sphinxcode{set\_cors} and \sphinxcode{set\_bpms}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{interface}} -- \sphinxcode{DakotaInterface} object, automatically setup if not defined

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_method() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.set_method}\pysiglinewithargsret{\sphinxbfcode{set\_method}}{\emph{method=None}}{}
setup method block, that is setup \sphinxcode{oc\_method}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{method}} -- \sphinxcode{DakotaMethod} object, automatically setup if not defined

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_model() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.set_model}\pysiglinewithargsret{\sphinxbfcode{set\_model}}{\emph{model=None}, \emph{**kws}}{}
setup model block, that is setup \sphinxcode{oc\_model}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{model}} -- \sphinxcode{DakotaModel} object, automatically setup if not defined

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_ref\_x0() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.set_ref_x0}\pysiglinewithargsret{\sphinxbfcode{set\_ref\_x0}}{\emph{ref\_arr=None}}{}
set reference orbit in x, if not set, use 0s
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{ref\_arr}} -- array of reference orbit values
size should be the same number as selected BPMs

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_ref\_y0() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.set_ref_y0}\pysiglinewithargsret{\sphinxbfcode{set\_ref\_y0}}{\emph{ref\_arr=None}}{}
set reference orbit in y, if not set, use 0s
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{ref\_arr}} -- array of reference orbit values
size should be the same number as selected BPMs

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_responses() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.set_responses}\pysiglinewithargsret{\sphinxbfcode{set\_responses}}{\emph{responses=None}, \emph{**kws}}{}
setup responses block, that is setup \sphinxcode{oc\_responses}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{responses}} -- \sphinxcode{DakotaResponses} object, automatically setup if not defined

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_variables() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.set_variables}\pysiglinewithargsret{\sphinxbfcode{set\_variables}}{\emph{plist=None}, \emph{initial=0.0001}, \emph{lower=-0.01}, \emph{upper=0.01}}{}
setup variables block, that is setup \sphinxcode{oc\_variables}
should be ready to invoke after \sphinxcode{set\_cors()}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{plist}} -- list of defined parameters (\sphinxcode{DakotaParam} object), 
automatically setup if not defined

\item {} 
\textbf{\texttt{initial}} -- initial values for all variables, only valid when plist is None

\item {} 
\textbf{\texttt{lower}} -- lower bound for all variables, only valid when plist is None

\item {} 
\textbf{\texttt{upper}} -- upper bound for all variables, only valid when plist is None

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{simple\_run() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.simple_run}\pysiglinewithargsret{\sphinxbfcode{simple\_run}}{\emph{method='cg'}, \emph{mpi=None}, \emph{np=None}, \emph{echo=True}, \emph{**kws}}{}
run optimization after \sphinxcode{set\_bpms()} and \sphinxcode{set\_cors()},
by using default configuration and make full use of computing resources.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{method}} -- optimization method, `cg', `ps', `cg' by default

\item {} 
\textbf{\texttt{mpi}} -- if True, run DAKOTA in parallel mode, False by default

\item {} 
\textbf{\texttt{np}} -- number of processes to use, only valid when \sphinxcode{mpi} is True

\item {} 
\textbf{\texttt{echo}} -- suppress output if False, True by default

\item {} 
\textbf{\texttt{kws}} -- 
keyword parameters
valid keys:
\begin{itemize}
\item {} 
step: gradient step, 1e-6 by default

\item {} 
iternum: max iteration number, 20 by default

\item {} 
evalnum: max function evaulation number, 1000 by default

\end{itemize}


\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{vcors (DakotaOC attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaOC.vcors}\pysigline{\sphinxbfcode{vcors}}
\end{fulllineitems}


\end{fulllineitems}

\index{DakotaEnviron (class in genopt)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaEnviron}\pysiglinewithargsret{\sphinxstrong{class }\sphinxbfcode{DakotaEnviron}}{\emph{tabfile=None}, \emph{**kws}}{}
Bases: \href{https://docs.python.org/2/library/functions.html\#object}{\sphinxcode{object}}

create datako environment for \sphinxcode{environment} block
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{tabfile}} -- tabular file name, by default not save tabular data

\item {} 
\textbf{\texttt{kws}} -- other keyword parameters

\end{itemize}

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} default}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}environ} \PYG{o}{=} \PYG{n}{DakotaEnviron}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{oc\PYGZus{}environ}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} define name of tabular file}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}environ} \PYG{o}{=} \PYG{n}{DakotaEnviron}\PYG{p}{(}\PYG{n}{tabfile}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tmp.dat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{oc\PYGZus{}environ}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}tabular\PYGZus{}data\PYGZsq{}, \PYGZdq{} tabular\PYGZus{}data\PYGZus{}file \PYGZsq{}tmp.dat\PYGZsq{}\PYGZdq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\end{Verbatim}
\index{get\_config() (DakotaEnviron method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaEnviron.get_config}\pysiglinewithargsret{\sphinxbfcode{get\_config}}{\emph{rtype='list'}}{}
get responses configuration for dakota input block
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{rtype}} -- `list' or `string'

\item[{Returns}] \leavevmode
dakota responses input

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{DakotaInterface (class in genopt)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaInterface}\pysiglinewithargsret{\sphinxstrong{class }\sphinxbfcode{DakotaInterface}}{\emph{mode='fork'}, \emph{driver='flamedriver\_oc'}, \emph{latfile=None}, \emph{bpms=None}, \emph{hcors=None}, \emph{vcors=None}, \emph{ref\_x0=None}, \emph{ref\_y0=None}, \emph{ref\_flag=None}, \emph{**kws}}{}
Bases: \href{https://docs.python.org/2/library/functions.html\#object}{\sphinxcode{object}}

create dakota interface for \sphinxcode{interface} block
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{mode}} -- `fork' or `direct' (future usage)

\item {} 
\textbf{\texttt{driver}} -- analysis driver, external (`fork') executable file
internal (`direct') executable file

\item {} 
\textbf{\texttt{latfile}} -- file name of (flame) lattice file

\item {} 
\textbf{\texttt{bpms}} -- array of selected BPMs' id

\item {} 
\textbf{\texttt{hcors}} -- array of selected horizontal (x) correctors' id

\item {} 
\textbf{\texttt{vcors}} -- array of selected vertical (y) correctors' id

\item {} 
\textbf{\texttt{ref\_x0}} -- array of BPM readings for reference orbit in x, if not defined, use 0s

\item {} 
\textbf{\texttt{ref\_y0}} -- array of BPM readings for reference orbit in y, if not defined, use 0s

\item {} 
\textbf{\texttt{ref\_flag}} -- 
string flag for objective functions:
\begin{enumerate}
\item {} 
``x'': \(\sum \Delta x^2\), \(\Delta x = x-x_0\);

\item {} 
``y'': \(\sum \Delta y^2\), \(\Delta y = y-y_0\);

\item {} 
``xy'': \(\sum \Delta x^2 + \sum \Delta y^2\).

\end{enumerate}


\item {} 
\textbf{\texttt{kws}} -- keyword parameters, valid keys: 
e.g.:
* deactivate, possible value: `active\_set\_vector'

\end{itemize}

\end{description}\end{quote}

\begin{notice}{note}{Note:}
\sphinxcode{mode} should be set to be `direct' when the analysis drivers are
built with dakota library, presently, `fork' is used.
\end{notice}
\begin{quote}\begin{description}
\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} for orbit correction}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{bpms} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} just for demonstration}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{hcors}\PYG{p}{,} \PYG{n}{vcors} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{latfile} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test.lat}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}interface} \PYG{o}{=} \PYG{n}{DakotaInterface}\PYG{p}{(}\PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fork}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }                               \PYG{n}{driver}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{flamedriver\PYGZus{}oc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }                               \PYG{n}{latfile}\PYG{o}{=}\PYG{n}{latfile}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }                               \PYG{n}{bpms}\PYG{o}{=}\PYG{n}{bpms}\PYG{p}{,} \PYG{n}{hcors}\PYG{o}{=}\PYG{n}{hcors}\PYG{p}{,} \PYG{n}{vcors}\PYG{o}{=}\PYG{n}{vcors}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }                               \PYG{n}{ref\PYGZus{}x0}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{ref\PYGZus{}y0}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }                               \PYG{n}{ref\PYGZus{}flag}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }                               \PYG{n}{deactivate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{active\PYGZus{}set\PYGZus{}vector}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} add extra configurations}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}interface}\PYG{o}{.}\PYG{n}{set\PYGZus{}extra}\PYG{p}{(}\PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{p2}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} get configuration}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{config\PYGZus{}str} \PYG{o}{=} \PYG{n}{oc\PYGZus{}interface}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\end{Verbatim}
\index{bpms (DakotaInterface attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaInterface.bpms}\pysigline{\sphinxbfcode{bpms}}
\end{fulllineitems}

\index{driver (DakotaInterface attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaInterface.driver}\pysigline{\sphinxbfcode{driver}}
\end{fulllineitems}

\index{get\_config() (DakotaInterface method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaInterface.get_config}\pysiglinewithargsret{\sphinxbfcode{get\_config}}{\emph{rtype='list'}}{}
get interface configuration for dakota input block
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{rtype}} -- `list' or `string'

\item[{Returns}] \leavevmode
dakota interface input

\end{description}\end{quote}

\end{fulllineitems}

\index{hcors (DakotaInterface attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaInterface.hcors}\pysigline{\sphinxbfcode{hcors}}
\end{fulllineitems}

\index{latfile (DakotaInterface attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaInterface.latfile}\pysigline{\sphinxbfcode{latfile}}
\end{fulllineitems}

\index{mode (DakotaInterface attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaInterface.mode}\pysigline{\sphinxbfcode{mode}}
\end{fulllineitems}

\index{ref\_flag (DakotaInterface attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaInterface.ref_flag}\pysigline{\sphinxbfcode{ref\_flag}}
\end{fulllineitems}

\index{ref\_x0 (DakotaInterface attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaInterface.ref_x0}\pysigline{\sphinxbfcode{ref\_x0}}
\end{fulllineitems}

\index{ref\_y0 (DakotaInterface attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaInterface.ref_y0}\pysigline{\sphinxbfcode{ref\_y0}}
\end{fulllineitems}

\index{set\_extra() (DakotaInterface method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaInterface.set_extra}\pysiglinewithargsret{\sphinxbfcode{set\_extra}}{\emph{**kws}}{}
add extra configurations

\end{fulllineitems}

\index{vcors (DakotaInterface attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaInterface.vcors}\pysigline{\sphinxbfcode{vcors}}
\end{fulllineitems}


\end{fulllineitems}

\index{DakotaMethod (class in genopt)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaMethod}\pysiglinewithargsret{\sphinxstrong{class }\sphinxbfcode{DakotaMethod}}{\emph{method='cg'}, \emph{iternum=20}, \emph{tolerance=0.0001}, \emph{**kws}}{}
Bases: \href{https://docs.python.org/2/library/functions.html\#object}{\sphinxcode{object}}

create dakota method for \sphinxcode{method} block
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{method}} -- method name, `cg' by default, all possible choices: `cg', `ps'

\item {} 
\textbf{\texttt{iternum}} -- max iteration number, 20 by default

\item {} 
\textbf{\texttt{tolerance}} -- convergence tolerance, 1e-4 by default

\item {} 
\textbf{\texttt{kws}} -- other keyword parameters

\end{itemize}

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} default}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}method} \PYG{o}{=} \PYG{n}{DakotaMethod}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{oc\PYGZus{}method}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}conmin\PYGZus{}frcg\PYGZsq{}, \PYGZsq{} convergence\PYGZus{}tolerance 0.0001\PYGZsq{}, \PYGZsq{} max\PYGZus{}iterations 20\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} define method with pattern search}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}method} \PYG{o}{=} \PYG{n}{DakotaMethod}\PYG{p}{(}\PYG{n}{method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ps}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{oc\PYGZus{}method}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}coliny\PYGZus{}pattern\PYGZus{}search\PYGZsq{}, \PYGZsq{} contraction\PYGZus{}factor 0.75\PYGZsq{}, \PYGZsq{} max\PYGZus{}function\PYGZus{}evaluations 500\PYGZsq{}, }
\PYG{g+go}{ \PYGZsq{} solution\PYGZus{}accuracy 0.0001\PYGZsq{}, \PYGZsq{} exploratory\PYGZus{}moves basic\PYGZus{}pattern\PYGZsq{}, }
\PYG{g+go}{ \PYGZsq{} threshold\PYGZus{}delta 0.0001\PYGZsq{}, \PYGZsq{} initial\PYGZus{}delta 0.5\PYGZsq{}, \PYGZsq{} max\PYGZus{}iterations 100\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} modify options of pattern search method}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}method} \PYG{o}{=} \PYG{n}{DakotaMethod}\PYG{p}{(}\PYG{n}{method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ps}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{max\PYGZus{}iterations}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{contraction\PYGZus{}factor}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{oc\PYGZus{}method}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}coliny\PYGZus{}pattern\PYGZus{}search\PYGZsq{}, \PYGZsq{} contraction\PYGZus{}factor 0.8\PYGZsq{}, \PYGZsq{} max\PYGZus{}function\PYGZus{}evaluations 500\PYGZsq{}, }
\PYG{g+go}{ \PYGZsq{} solution\PYGZus{}accuracy 0.0001\PYGZsq{}, \PYGZsq{} exploratory\PYGZus{}moves basic\PYGZus{}pattern\PYGZsq{}, }
\PYG{g+go}{ \PYGZsq{} threshold\PYGZus{}delta 0.0001\PYGZsq{}, \PYGZsq{} initial\PYGZus{}delta 0.5\PYGZsq{}, \PYGZsq{} max\PYGZus{}iterations 200\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} conmin\PYGZus{}frcg method}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}method} \PYG{o}{=} \PYG{n}{DakotaMethod}\PYG{p}{(}\PYG{n}{method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{oc\PYGZus{}method}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}conmin\PYGZus{}frcg\PYGZsq{}, \PYGZsq{} convergence\PYGZus{}tolerance 0.0001\PYGZsq{}, \PYGZsq{} max\PYGZus{}iterations 20\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} modify options}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}method} \PYG{o}{=} \PYG{n}{DakotaMethod}\PYG{p}{(}\PYG{n}{method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{max\PYGZus{}iterations}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{oc\PYGZus{}method}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}conmin\PYGZus{}frcg\PYGZsq{}, \PYGZsq{} convergence\PYGZus{}tolerance 0.0001\PYGZsq{}, \PYGZsq{} max\PYGZus{}iterations 100\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\end{Verbatim}
\index{get\_config() (DakotaMethod method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaMethod.get_config}\pysiglinewithargsret{\sphinxbfcode{get\_config}}{\emph{rtype='list'}}{}
get method configuration for dakota input block
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{rtype}} -- `list' or `string'

\item[{Returns}] \leavevmode
dakota method input

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_default\_method() (DakotaMethod method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaMethod.get_default_method}\pysiglinewithargsret{\sphinxbfcode{get\_default\_method}}{\emph{method}}{}
get default configuration of some method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{method}} -- method name, `cg' or `ps'

\item[{Returns}] \leavevmode
dict of configuration

\end{description}\end{quote}

\end{fulllineitems}

\index{method() (DakotaMethod method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaMethod.method}\pysiglinewithargsret{\sphinxbfcode{method}}{\emph{method}}{}
return method configuration
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{method}} -- method stirng name, `cg' or `ps'

\item[{Returns}] \leavevmode
list of method configuration

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{DakotaModel (class in genopt)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaModel}\pysiglinewithargsret{\sphinxstrong{class }\sphinxbfcode{DakotaModel}}{\emph{**kws}}{}
Bases: \href{https://docs.python.org/2/library/functions.html\#object}{\sphinxcode{object}}

create dakota model for \sphinxcode{model} block
\index{get\_config() (DakotaModel method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaModel.get_config}\pysiglinewithargsret{\sphinxbfcode{get\_config}}{\emph{rtype='list'}}{}
get model configuration for dakota input block
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{rtype}} -- `list' or `string'

\item[{Returns}] \leavevmode
dakota model input

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{DakotaResponses (class in genopt)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaResponses}\pysiglinewithargsret{\sphinxstrong{class }\sphinxbfcode{DakotaResponses}}{\emph{nfunc=1}, \emph{gradient=None}, \emph{hessian=None}, \emph{**kws}}{}
Bases: \href{https://docs.python.org/2/library/functions.html\#object}{\sphinxcode{object}}

create dakota responses for \sphinxcode{responses} block
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{nfunc}} -- num of objective functions

\item {} 
\textbf{\texttt{gradient}} -- gradient type: `analytic' or `numerical'

\item {} 
\textbf{\texttt{hessian}} -- hessian configuration

\item {} 
\textbf{\texttt{kws}} -- keyword parameters for gradients and hessians
valid keys: any available for responses
among which key name of `grad' is for gradients configuration, 
the value should be a dict (future)

\end{itemize}

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} default responses:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{response} \PYG{o}{=} \PYG{n}{DakotaResponses}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{response}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}num\PYGZus{}objective\PYGZus{}functions = 1\PYGZsq{}, \PYGZsq{}no\PYGZus{}gradients\PYGZsq{}, \PYGZsq{}no\PYGZus{}hessians\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} responses with analytic gradients:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{response} \PYG{o}{=} \PYG{n}{DakotaResponses}\PYG{p}{(}\PYG{n}{gradient}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{analytic}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{response}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}num\PYGZus{}objective\PYGZus{}functions = 1\PYGZsq{}, \PYGZsq{}analytic\PYGZus{}gradients\PYGZsq{}, \PYGZsq{}no\PYGZus{}hessians\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} responses with numerical gradients, default configuration:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}responses} \PYG{o}{=} \PYG{n}{DakotaResponses}\PYG{p}{(}\PYG{n}{gradient}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{numerical}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{oc\PYGZus{}responses}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}num\PYGZus{}objective\PYGZus{}functions = 1\PYGZsq{}, \PYGZsq{}numerical\PYGZus{}gradients\PYGZsq{}, \PYGZsq{} method\PYGZus{}source dakota\PYGZsq{}, }
\PYG{g+go}{ \PYGZsq{} interval\PYGZus{}type forward\PYGZsq{}, \PYGZsq{} fd\PYGZus{}gradient\PYGZus{}step\PYGZus{}size 1e\PYGZhy{}06\PYGZsq{}, \PYGZsq{}no\PYGZus{}hessians\PYGZsq{}]}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} responses with numerical gradients, define step:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}responses} \PYG{o}{=} \PYG{n}{DakotaResponses}\PYG{p}{(}\PYG{n}{gradient}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{numerical}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{step}\PYG{o}{=}\PYG{l+m+mf}{2.0e\PYGZhy{}7}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{oc\PYGZus{}responses}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}num\PYGZus{}objective\PYGZus{}functions = 1\PYGZsq{}, \PYGZsq{}numerical\PYGZus{}gradients\PYGZsq{}, \PYGZsq{} method\PYGZus{}source dakota\PYGZsq{}, }
\PYG{g+go}{ \PYGZsq{} interval\PYGZus{}type forward\PYGZsq{}, \PYGZsq{} fd\PYGZus{}gradient\PYGZus{}step\PYGZus{}size 2e\PYGZhy{}07\PYGZsq{}, \PYGZsq{}no\PYGZus{}hessians\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} given other keyword parameters:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}responses} \PYG{o}{=} \PYG{n}{DakotaResponses}\PYG{p}{(}\PYG{n}{gradient}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{numerical}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{step}\PYG{o}{=}\PYG{l+m+mf}{2.0e\PYGZhy{}7}\PYG{p}{,} \PYG{n}{k1}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{k2}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{oc\PYGZus{}responses}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}num\PYGZus{}objective\PYGZus{}functions = 1\PYGZsq{}, \PYGZsq{}numerical\PYGZus{}gradients\PYGZsq{}, \PYGZsq{} method\PYGZus{}source dakota\PYGZsq{}, }
\PYG{g+go}{ \PYGZsq{} interval\PYGZus{}type forward\PYGZsq{}, \PYGZsq{} fd\PYGZus{}gradient\PYGZus{}step\PYGZus{}size 2e\PYGZhy{}07\PYGZsq{}, \PYGZsq{}no\PYGZus{}hessians\PYGZsq{}, \PYGZsq{}k2 = v2\PYGZsq{}, \PYGZsq{}k1 = v1\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\end{Verbatim}
\index{get\_config() (DakotaResponses method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaResponses.get_config}\pysiglinewithargsret{\sphinxbfcode{get\_config}}{\emph{rtype='list'}}{}
get responses configuration for dakota input block
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{rtype}} -- `list' or `string'

\item[{Returns}] \leavevmode
dakota responses input

\end{description}\end{quote}

\end{fulllineitems}

\index{gradients() (DakotaResponses method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.DakotaResponses.gradients}\pysiglinewithargsret{\sphinxbfcode{gradients}}{\emph{type=None}, \emph{step=1e-06}, \emph{**kws}}{}
generate gradients configuration
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{type}} -- `numerical' or `analytic' (default)

\item {} 
\textbf{\texttt{step}} -- gradient step size, only valid when type is numerical

\item {} 
\textbf{\texttt{kws}} -- other keyword parameters

\end{itemize}

\item[{Returns}] \leavevmode
list of configuration

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{get\_opt\_results() (in module genopt)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/genopt:genopt.get_opt_results}\pysiglinewithargsret{\sphinxbfcode{get\_opt\_results}}{\emph{outfile='dakota.out'}, \emph{rtype='dict'}}{}
extract optimized results from dakota output
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{outfile}} -- file name of dakota output file, 
`dakota.out' by default

\item {} 
\textbf{\texttt{rtype}} -- type of returned results, `dict' or `list', 
`dict' by default

\end{itemize}

\item[{Returns}] \leavevmode
by default return a dict of optimized results with each item
of the format like ``x1'':0.1, etc., or if rtype='list', return a 
list of values, when the keys are ascend sorted.

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt\PYGZus{}vars} \PYG{o}{=} \PYG{n}{get\PYGZus{}opt\PYGZus{}results}\PYG{p}{(}\PYG{n}{outfile}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{flame\PYGZus{}oc.out}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{rtype}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dict}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{opt\PYGZus{}vars}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}x2\PYGZsq{}: 0.0020782814353, \PYGZsq{}x1\PYGZsq{}: \PYGZhy{}0.0017913264033\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt\PYGZus{}vars} \PYG{o}{=} \PYG{n}{get\PYGZus{}opt\PYGZus{}results}\PYG{p}{(}\PYG{n}{outfile}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{flame\PYGZus{}oc.out}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{rtype}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{list}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{opt\PYGZus{}vars}\PYG{p}{)}
\PYG{g+go}{[\PYGZhy{}0.0017913264033, 0.0020782814353]}
\end{Verbatim}

\end{fulllineitems}



\subsection{Submodules}
\label{src/apidocs/genopt:submodules}

\subsubsection{genopt.dakopt module}
\label{src/apidocs/dakopt:module-genopt.dakopt}\label{src/apidocs/dakopt:genopt-dakopt-module}\label{src/apidocs/dakopt::doc}\index{genopt.dakopt (module)}
General optimization module by utilizing DAKOTA
\begin{itemize}
\item {} 
orbit correction: \sphinxcode{DakotaOC}

\end{itemize}

Tong Zhang \textless{}\href{mailto:zhangt@frib.msu.edu}{zhangt@frib.msu.edu}\textgreater{}

2016-10-23 14:26:13 PM EDT
\index{DakotaBase (class in genopt.dakopt)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaBase}\pysiglinewithargsret{\sphinxstrong{class }\sphinxbfcode{DakotaBase}}{\emph{**kws}}{}
Bases: \href{https://docs.python.org/2/library/functions.html\#object}{\sphinxcode{object}}

Base class for general optimization, initialized parameters:
valid keyword parameters:
\begin{itemize}
\item {} 
workdir: root dir for dakota input/output files,
the defualt one should be created in /tmp, or define some dir path

\item {} 
dakexec: full path of dakota executable,
the default one should be \emph{dakota}, or define the full path

\item {} 
dakhead: prefixed name for input/output files of \emph{dakota}, 
the default one is \emph{dakota}

\item {} 
keep: if keep the working directory (i.e. defined by \emph{workdir}), default is False

\end{itemize}
\index{dakexec (DakotaBase attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaBase.dakexec}\pysigline{\sphinxbfcode{dakexec}}
\end{fulllineitems}

\index{dakhead (DakotaBase attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaBase.dakhead}\pysigline{\sphinxbfcode{dakhead}}
\end{fulllineitems}

\index{keep (DakotaBase attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaBase.keep}\pysigline{\sphinxbfcode{keep}}
\end{fulllineitems}

\index{workdir (DakotaBase attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaBase.workdir}\pysigline{\sphinxbfcode{workdir}}
\end{fulllineitems}


\end{fulllineitems}

\index{DakotaOC (class in genopt.dakopt)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC}\pysiglinewithargsret{\sphinxstrong{class }\sphinxbfcode{DakotaOC}}{\emph{lat\_file=None}, \emph{elem\_bpm=None}, \emph{elem\_cor=None}, \emph{elem\_hcor=None}, \emph{elem\_vcor=None}, \emph{ref\_x0=None}, \emph{ref\_y0=None}, \emph{ref\_flag=None}, \emph{model=None}, \emph{optdriver=None}, \emph{**kws}}{}
Bases: {\hyperref[src/apidocs/dakopt:genopt.dakopt.DakotaBase]{\sphinxcrossref{\sphinxcode{genopt.dakopt.DakotaBase}}}}

Dakota optimization class with orbit correction driver
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{lat\_file}} -- lattice file

\item {} 
\textbf{\texttt{elem\_bpm}} -- list of element indice of BPMs

\item {} 
\textbf{\texttt{elem\_cor}} -- list of element indice of correctors, always folders of 2

\item {} 
\textbf{\texttt{elem\_hcor}} -- list of element indice of horizontal correctors

\item {} 
\textbf{\texttt{elem\_vcor}} -- list of element indice of vertical correctors

\item {} 
\textbf{\texttt{ref\_x0}} -- reference orbit in x, list of BPM readings

\item {} 
\textbf{\texttt{ref\_y0}} -- reference orbit in y, list of BPM readings

\item {} 
\textbf{\texttt{ref\_flag}} -- 
string flag for objective functions:
\begin{enumerate}
\item {} 
``x'': \(\sum \Delta x^2\), \(\Delta x = x-x_0\);

\item {} 
``y'': \(\sum \Delta y^2\), \(\Delta y = y-y_0\);

\item {} 
``xy'': \(\sum \Delta x^2 + \sum \Delta y^2\).

\end{enumerate}


\item {} 
\textbf{\texttt{model}} -- simulation model, `flame' or `impact'

\item {} 
\textbf{\texttt{optdriver}} -- analysis driver for optimization, `flamedriver\_oc' by default

\item {} 
\textbf{\texttt{kws}} -- \begin{description}
\item[{keywords parameters for additional usage, defined in \sphinxcode{DakotaBase} class}] \leavevmode
valid keys:

\end{description}
\begin{itemize}
\item {} 
\emph{workdir}: root dir for dakota input/output files,
the defualt one should be created in /tmp, or define some dir path

\item {} 
\emph{dakexec}: full path of dakota executable,
the default one should be \emph{dakota}, or define the full path

\item {} 
\emph{dakhead}: prefixed name for input/output files of \emph{dakota}, 
the default one is \emph{dakota}

\item {} 
\emph{keep}: if keep the working directory (i.e. defined by \emph{workdir}), 
default is False

\end{itemize}


\end{itemize}

\end{description}\end{quote}

\begin{notice}{note}{Note:}
\sphinxcode{elem\_bpm} should be treated as index of elemnt with type name of `BPM',
however, for the simulation convenience, any element is acceptable, see {\hyperref[src/apidocs/dakopt:genopt.dakopt.DakotaOC.set_bpms]{\sphinxcrossref{\sphinxcode{set\_bpms()}}}}.
\end{notice}
\index{bpms (DakotaOC attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.bpms}\pysigline{\sphinxbfcode{bpms}}
\end{fulllineitems}

\index{create\_machine() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.create_machine}\pysiglinewithargsret{\sphinxbfcode{create\_machine}}{\emph{lat\_file}}{}
create machine instance with model configuration
\begin{itemize}
\item {} 
setup \_machine

\item {} 
setup \_elem\_bpm, \_elem\_cor or (\_elem\_hcor and \_elem\_vcor)

\end{itemize}

\end{fulllineitems}

\index{gen\_dakota\_input() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.gen_dakota_input}\pysiglinewithargsret{\sphinxbfcode{gen\_dakota\_input}}{\emph{infile=None}, \emph{debug=False}}{}
generate dakota input file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{infile}} -- dakota input filename

\item {} 
\textbf{\texttt{debug}} -- if True, generate a simple test input file

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_bpms() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.get_all_bpms}\pysiglinewithargsret{\sphinxbfcode{get\_all\_bpms}}{}{}
get list of all valid bpms indices
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
a list of bpm indices

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dakoc} \PYG{o}{=} \PYG{n}{DakotaOC}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test/test.lat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{dakoc}\PYG{o}{.}\PYG{n}{get\PYGZus{}all\PYGZus{}bpms}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{get\_all\_cors() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.get_all_cors}\pysiglinewithargsret{\sphinxbfcode{get\_all\_cors}}{\emph{type=None}}{}
get list of all valid correctors indices
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{type}} -- define corrector type, `h': horizontal, `v': vertical, 
if not defined, return all correctors

\item[{Returns}] \leavevmode
a list of corrector indices

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dakoc} \PYG{o}{=} \PYG{n}{DakotaOC}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test/test.lat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{dakoc}\PYG{o}{.}\PYG{n}{get\PYGZus{}all\PYGZus{}cors}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{get\_all\_elem() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.get_all_elem}\pysiglinewithargsret{\sphinxbfcode{get\_all\_elem}}{}{}
get all elements from \sphinxcode{Machine} object
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
list of element indices

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_elem\_by\_name() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.get_elem_by_name}\pysiglinewithargsret{\sphinxbfcode{get\_elem\_by\_name}}{\emph{name}}{}
get list of element(s) by name(s)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{name}} -- tuple or list of name(s)

\item[{Returns}] \leavevmode
list of element indices

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dakoc} \PYG{o}{=} \PYG{n}{DakotaOC}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test/test.lat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{names} \PYG{o}{=} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LS1\PYGZus{}CA01:BPM\PYGZus{}D1144}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LS1\PYGZus{}WA01:BPM\PYGZus{}D1155}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{idx} \PYG{o}{=} \PYG{n}{dakoc}\PYG{o}{.}\PYG{n}{get\PYGZus{}elem\PYGZus{}by\PYGZus{}name}\PYG{p}{(}\PYG{n}{names}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{idx}\PYG{p}{)}
\PYG{g+go}{[18, 31]}
\end{Verbatim}

\end{fulllineitems}

\index{get\_elem\_by\_type() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.get_elem_by_type}\pysiglinewithargsret{\sphinxbfcode{get\_elem\_by\_type}}{\emph{type}}{}
get list of element(s) by type
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{type}} -- string name of element type

\item[{Returns}] \leavevmode
list of element indices

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dakoc} \PYG{o}{=} \PYG{n}{DakotaOC}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test/test.lat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{type} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bpm}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{idx} \PYG{o}{=} \PYG{n}{dakoc}\PYG{o}{.}\PYG{n}{get\PYGZus{}elem\PYGZus{}by\PYGZus{}type}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{idx}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{get\_machine() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.get_machine}\pysiglinewithargsret{\sphinxbfcode{get\_machine}}{}{}
get flame machine object for potential usage
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
flame machine object or None

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_opt\_latfile() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.get_opt_latfile}\pysiglinewithargsret{\sphinxbfcode{get\_opt\_latfile}}{\emph{outfile='out.lat'}}{}
get optimized lattice file for potential next usage,
\sphinxcode{run()} or \sphinxcode{simple\_run()} should be evoked first to get the 
optimized results.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{outfile}} -- file name for generated lattice file

\item[{Returns}] \leavevmode
lattice file name or None if failed

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_opt\_results() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.get_opt_results}\pysiglinewithargsret{\sphinxbfcode{get\_opt\_results}}{\emph{outfile=None}, \emph{rtype='dict'}, \emph{label='plain'}}{}
extract optimized results from dakota output
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{outfile}} -- file name of dakota output file, 
`dakota.out' by default

\item {} 
\textbf{\texttt{rtype}} -- type of returned results, `dict' or `list', 
`dict' by default

\item {} 
\textbf{\texttt{label}} -- 
label types for returned variables, only valid when rtype `dict', 
`plain' by default:
\begin{itemize}
\item {} 
\emph{`plain'}: variable labels with format of \sphinxcode{x1}, \sphinxcode{x2}, \sphinxcode{y1}, \sphinxcode{y2}, etc.
e.g. \sphinxcode{\{'x1': v1, 'y1': v2\}}

\item {} 
\emph{`fancy'}: variable labels with the name defined in lattice file,
e.g. \sphinxcode{'LS1\_CA01:DCH\_D1131'}, dict returned sample: 
\sphinxcode{\{'LS1\_CA01:DCH\_D1131': \{'id':9, 'config':\{'theta\_x':v1\}\}\}}

\end{itemize}


\end{itemize}

\end{description}\end{quote}

\begin{notice}{note}{Note:}
The \sphinxcode{fancy} option will make re-configuring flame machine in a more 
convenient way, such as:

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt\PYGZus{}cors} \PYG{o}{=} \PYG{n}{get\PYGZus{}opt\PYGZus{}results}\PYG{p}{(}\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fancy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{opt\PYGZus{}cors}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{m}\PYG{o}{.}\PYG{n}{reconfigure}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{id}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{v}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{config}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} here m is an instance of flame.Machine class}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\end{Verbatim}
\end{notice}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
by default return a dict of optimized results with each item
of the format like ``x1'':0.1 or more fancy format by set label with `fancy', etc.,
if rtype='list', return a list of values, when the keys are ascend sorted.

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt\PYGZus{}vars} \PYG{o}{=} \PYG{n}{get\PYGZus{}optresults}\PYG{p}{(}\PYG{n}{outfile}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{flame\PYGZus{}oc.out}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{rtype}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dict}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{opt\PYGZus{}vars}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}x2\PYGZsq{}: 0.0020782814353, \PYGZsq{}x1\PYGZsq{}: \PYGZhy{}0.0017913264033\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt\PYGZus{}vars} \PYG{o}{=} \PYG{n}{get\PYGZus{}optresults}\PYG{p}{(}\PYG{n}{outfile}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{flame\PYGZus{}oc.out}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{rtype}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{list}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{opt\PYGZus{}vars}\PYG{p}{)}
\PYG{g+go}{[\PYGZhy{}0.0017913264033, 0.0020782814353]}
\end{Verbatim}

\end{fulllineitems}

\index{get\_orbit() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.get_orbit}\pysiglinewithargsret{\sphinxbfcode{get\_orbit}}{\emph{idx=None}, \emph{val=None}, \emph{outfile=None}}{}
calculate the orbit with given configurations
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{idx}} -- (idx\_hcor, idx\_vcor), tuple of list of indices of h/v cors

\item {} 
\textbf{\texttt{val}} -- values for each correctos, h/v

\item {} 
\textbf{\texttt{outfile}} -- filename to save the data

\end{itemize}

\item[{Returns}] \leavevmode
tuple of zpos, env\_x, env\_y, machine

\end{description}\end{quote}

\end{fulllineitems}

\index{hcors (DakotaOC attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.hcors}\pysigline{\sphinxbfcode{hcors}}
\end{fulllineitems}

\index{latfile (DakotaOC attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.latfile}\pysigline{\sphinxbfcode{latfile}}
\end{fulllineitems}

\index{optdriver (DakotaOC attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.optdriver}\pysigline{\sphinxbfcode{optdriver}}
\end{fulllineitems}

\index{plot() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.plot}\pysiglinewithargsret{\sphinxbfcode{plot}}{\emph{outfile=None}, \emph{figsize=(10}, \emph{8)}, \emph{dpi=120}, \emph{**kws}}{}
show orbit
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{outfile}} -- output file of dakota

\item {} 
\textbf{\texttt{figsize}} -- figure size, (h, w)

\item {} 
\textbf{\texttt{dpi}} -- figure dpi

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{ref\_flag (DakotaOC attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.ref_flag}\pysigline{\sphinxbfcode{ref\_flag}}
\end{fulllineitems}

\index{ref\_x0 (DakotaOC attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.ref_x0}\pysigline{\sphinxbfcode{ref\_x0}}
\end{fulllineitems}

\index{ref\_y0 (DakotaOC attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.ref_y0}\pysigline{\sphinxbfcode{ref\_y0}}
\end{fulllineitems}

\index{run() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.run}\pysiglinewithargsret{\sphinxbfcode{run}}{\emph{mpi=False}, \emph{np=None}, \emph{echo=True}}{}
run optimization
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{mpi}} -- if True, run DAKOTA in parallel mode, False by default

\item {} 
\textbf{\texttt{np}} -- number of processes to use, only valid when \sphinxcode{mpi} is True

\item {} 
\textbf{\texttt{echo}} -- suppress output if False, True by default

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_bpms() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.set_bpms}\pysiglinewithargsret{\sphinxbfcode{set\_bpms}}{\emph{bpm=None}, \emph{pseudo\_all=False}}{}
set BPMs, and trying to set reference orbit \sphinxcode{(x,y)} if \sphinxcode{x} and \sphinxcode{y}
is of one unique value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{bpm}} -- list of bpm indices, if None, use all BPMs

\item {} 
\textbf{\texttt{pseudo\_all}} -- if set True, will use all elements, ignore \sphinxcode{bpm} parameter

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_cors() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.set_cors}\pysiglinewithargsret{\sphinxbfcode{set\_cors}}{\emph{cor=None}, \emph{hcor=None}, \emph{vcor=None}}{}
set correctors, if cor, hcor and vcor are None, use all correctors
if cor is not None, use cor, ignore hcor and vcor
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{cor}} -- list of corrector indices, hcor, vcor,...

\item {} 
\textbf{\texttt{hcor}} -- list of horizontal corrector indices

\item {} 
\textbf{\texttt{vcor}} -- list of vertical corrector indices

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_environ() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.set_environ}\pysiglinewithargsret{\sphinxbfcode{set\_environ}}{\emph{environ=None}}{}
setup environment block, that is setup \sphinxcode{oc\_environ}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{environ}} -- \sphinxcode{DakotaEnviron} object, automatically setup if not defined

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_interface() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.set_interface}\pysiglinewithargsret{\sphinxbfcode{set\_interface}}{\emph{interface=None}, \emph{**kws}}{}
setup interface block, that is setup \sphinxcode{oc\_interface}
should be ready to invoke after \sphinxcode{set\_cors} and \sphinxcode{set\_bpms}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{interface}} -- \sphinxcode{DakotaInterface} object, automatically setup if not defined

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_method() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.set_method}\pysiglinewithargsret{\sphinxbfcode{set\_method}}{\emph{method=None}}{}
setup method block, that is setup \sphinxcode{oc\_method}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{method}} -- \sphinxcode{DakotaMethod} object, automatically setup if not defined

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_model() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.set_model}\pysiglinewithargsret{\sphinxbfcode{set\_model}}{\emph{model=None}, \emph{**kws}}{}
setup model block, that is setup \sphinxcode{oc\_model}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{model}} -- \sphinxcode{DakotaModel} object, automatically setup if not defined

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_ref\_x0() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.set_ref_x0}\pysiglinewithargsret{\sphinxbfcode{set\_ref\_x0}}{\emph{ref\_arr=None}}{}
set reference orbit in x, if not set, use 0s
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{ref\_arr}} -- array of reference orbit values
size should be the same number as selected BPMs

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_ref\_y0() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.set_ref_y0}\pysiglinewithargsret{\sphinxbfcode{set\_ref\_y0}}{\emph{ref\_arr=None}}{}
set reference orbit in y, if not set, use 0s
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{ref\_arr}} -- array of reference orbit values
size should be the same number as selected BPMs

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_responses() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.set_responses}\pysiglinewithargsret{\sphinxbfcode{set\_responses}}{\emph{responses=None}, \emph{**kws}}{}
setup responses block, that is setup \sphinxcode{oc\_responses}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{responses}} -- \sphinxcode{DakotaResponses} object, automatically setup if not defined

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_variables() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.set_variables}\pysiglinewithargsret{\sphinxbfcode{set\_variables}}{\emph{plist=None}, \emph{initial=0.0001}, \emph{lower=-0.01}, \emph{upper=0.01}}{}
setup variables block, that is setup \sphinxcode{oc\_variables}
should be ready to invoke after \sphinxcode{set\_cors()}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{plist}} -- list of defined parameters (\sphinxcode{DakotaParam} object), 
automatically setup if not defined

\item {} 
\textbf{\texttt{initial}} -- initial values for all variables, only valid when plist is None

\item {} 
\textbf{\texttt{lower}} -- lower bound for all variables, only valid when plist is None

\item {} 
\textbf{\texttt{upper}} -- upper bound for all variables, only valid when plist is None

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{simple\_run() (DakotaOC method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.simple_run}\pysiglinewithargsret{\sphinxbfcode{simple\_run}}{\emph{method='cg'}, \emph{mpi=None}, \emph{np=None}, \emph{echo=True}, \emph{**kws}}{}
run optimization after \sphinxcode{set\_bpms()} and \sphinxcode{set\_cors()},
by using default configuration and make full use of computing resources.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{method}} -- optimization method, `cg', `ps', `cg' by default

\item {} 
\textbf{\texttt{mpi}} -- if True, run DAKOTA in parallel mode, False by default

\item {} 
\textbf{\texttt{np}} -- number of processes to use, only valid when \sphinxcode{mpi} is True

\item {} 
\textbf{\texttt{echo}} -- suppress output if False, True by default

\item {} 
\textbf{\texttt{kws}} -- 
keyword parameters
valid keys:
\begin{itemize}
\item {} 
step: gradient step, 1e-6 by default

\item {} 
iternum: max iteration number, 20 by default

\item {} 
evalnum: max function evaulation number, 1000 by default

\end{itemize}


\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{vcors (DakotaOC attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.DakotaOC.vcors}\pysigline{\sphinxbfcode{vcors}}
\end{fulllineitems}


\end{fulllineitems}

\index{test\_dakotaoc1() (in module genopt.dakopt)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.test_dakotaoc1}\pysiglinewithargsret{\sphinxbfcode{test\_dakotaoc1}}{}{}
\end{fulllineitems}

\index{test\_dakotaoc2() (in module genopt.dakopt)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakopt:genopt.dakopt.test_dakotaoc2}\pysiglinewithargsret{\sphinxbfcode{test\_dakotaoc2}}{}{}
\end{fulllineitems}



\subsubsection{genopt.dakutils module}
\label{src/apidocs/dakutils:genopt-dakutils-module}\label{src/apidocs/dakutils::doc}\label{src/apidocs/dakutils:module-genopt.dakutils}\index{genopt.dakutils (module)}
module contains utilities:
\begin{itemize}
\item {} 
generate dakota input files

\item {} 
extract data from output files

\end{itemize}

Tong Zhang \textless{}\href{mailto:zhangt@frib.msu.edu}{zhangt@frib.msu.edu}\textgreater{}

2016-10-17 09:19:25 AM EDT
\index{DakotaEnviron (class in genopt.dakutils)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaEnviron}\pysiglinewithargsret{\sphinxstrong{class }\sphinxbfcode{DakotaEnviron}}{\emph{tabfile=None}, \emph{**kws}}{}
Bases: \href{https://docs.python.org/2/library/functions.html\#object}{\sphinxcode{object}}

create datako environment for \sphinxcode{environment} block
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{tabfile}} -- tabular file name, by default not save tabular data

\item {} 
\textbf{\texttt{kws}} -- other keyword parameters

\end{itemize}

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} default}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}environ} \PYG{o}{=} \PYG{n}{DakotaEnviron}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{oc\PYGZus{}environ}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} define name of tabular file}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}environ} \PYG{o}{=} \PYG{n}{DakotaEnviron}\PYG{p}{(}\PYG{n}{tabfile}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tmp.dat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{oc\PYGZus{}environ}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}tabular\PYGZus{}data\PYGZsq{}, \PYGZdq{} tabular\PYGZus{}data\PYGZus{}file \PYGZsq{}tmp.dat\PYGZsq{}\PYGZdq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\end{Verbatim}
\index{get\_config() (DakotaEnviron method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaEnviron.get_config}\pysiglinewithargsret{\sphinxbfcode{get\_config}}{\emph{rtype='list'}}{}
get responses configuration for dakota input block
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{rtype}} -- `list' or `string'

\item[{Returns}] \leavevmode
dakota responses input

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{DakotaInput (class in genopt.dakutils)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaInput}\pysiglinewithargsret{\sphinxstrong{class }\sphinxbfcode{DakotaInput}}{\emph{**kws}}{}
Bases: \href{https://docs.python.org/2/library/functions.html\#object}{\sphinxcode{object}}

template of dakota input file, field could be overriden by
providing additional keyword arguments,
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{kws}} -- keyword arguments, valid keys are dakota directives

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dak\PYGZus{}inp} \PYG{o}{=} \PYG{n}{DakotaInput}\PYG{p}{(}\PYG{n}{method}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max\PYGZus{}iterations = 500}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{g+go}{                                  \PYGZdq{}convergence\PYGZus{}tolerance = 1e\PYGZhy{}7\PYGZdq{},}
\PYG{g+go}{                                  \PYGZdq{}conmin\PYGZus{}frcg\PYGZdq{},])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\end{Verbatim}
\index{set\_template() (DakotaInput method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaInput.set_template}\pysiglinewithargsret{\sphinxbfcode{set\_template}}{\emph{name='oc'}}{}
\end{fulllineitems}

\index{write() (DakotaInput method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaInput.write}\pysiglinewithargsret{\sphinxbfcode{write}}{\emph{infile=None}}{}
write all the input into file, as dakota input file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{infile}} -- fullname of input file, if not defined, infile will
be assigned as `dakota.in' in current working directory

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{DakotaInterface (class in genopt.dakutils)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaInterface}\pysiglinewithargsret{\sphinxstrong{class }\sphinxbfcode{DakotaInterface}}{\emph{mode='fork'}, \emph{driver='flamedriver\_oc'}, \emph{latfile=None}, \emph{bpms=None}, \emph{hcors=None}, \emph{vcors=None}, \emph{ref\_x0=None}, \emph{ref\_y0=None}, \emph{ref\_flag=None}, \emph{**kws}}{}
Bases: \href{https://docs.python.org/2/library/functions.html\#object}{\sphinxcode{object}}

create dakota interface for \sphinxcode{interface} block
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{mode}} -- `fork' or `direct' (future usage)

\item {} 
\textbf{\texttt{driver}} -- analysis driver, external (`fork') executable file
internal (`direct') executable file

\item {} 
\textbf{\texttt{latfile}} -- file name of (flame) lattice file

\item {} 
\textbf{\texttt{bpms}} -- array of selected BPMs' id

\item {} 
\textbf{\texttt{hcors}} -- array of selected horizontal (x) correctors' id

\item {} 
\textbf{\texttt{vcors}} -- array of selected vertical (y) correctors' id

\item {} 
\textbf{\texttt{ref\_x0}} -- array of BPM readings for reference orbit in x, if not defined, use 0s

\item {} 
\textbf{\texttt{ref\_y0}} -- array of BPM readings for reference orbit in y, if not defined, use 0s

\item {} 
\textbf{\texttt{ref\_flag}} -- 
string flag for objective functions:
\begin{enumerate}
\item {} 
``x'': \(\sum \Delta x^2\), \(\Delta x = x-x_0\);

\item {} 
``y'': \(\sum \Delta y^2\), \(\Delta y = y-y_0\);

\item {} 
``xy'': \(\sum \Delta x^2 + \sum \Delta y^2\).

\end{enumerate}


\item {} 
\textbf{\texttt{kws}} -- keyword parameters, valid keys: 
e.g.:
* deactivate, possible value: `active\_set\_vector'

\end{itemize}

\end{description}\end{quote}

\begin{notice}{note}{Note:}
\sphinxcode{mode} should be set to be `direct' when the analysis drivers are
built with dakota library, presently, `fork' is used.
\end{notice}
\begin{quote}\begin{description}
\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} for orbit correction}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{bpms} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} just for demonstration}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{hcors}\PYG{p}{,} \PYG{n}{vcors} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{latfile} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test.lat}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}interface} \PYG{o}{=} \PYG{n}{DakotaInterface}\PYG{p}{(}\PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fork}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }                               \PYG{n}{driver}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{flamedriver\PYGZus{}oc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }                               \PYG{n}{latfile}\PYG{o}{=}\PYG{n}{latfile}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }                               \PYG{n}{bpms}\PYG{o}{=}\PYG{n}{bpms}\PYG{p}{,} \PYG{n}{hcors}\PYG{o}{=}\PYG{n}{hcors}\PYG{p}{,} \PYG{n}{vcors}\PYG{o}{=}\PYG{n}{vcors}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }                               \PYG{n}{ref\PYGZus{}x0}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{ref\PYGZus{}y0}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }                               \PYG{n}{ref\PYGZus{}flag}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }                               \PYG{n}{deactivate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{active\PYGZus{}set\PYGZus{}vector}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} add extra configurations}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}interface}\PYG{o}{.}\PYG{n}{set\PYGZus{}extra}\PYG{p}{(}\PYG{n}{p1}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{p2}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} get configuration}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{config\PYGZus{}str} \PYG{o}{=} \PYG{n}{oc\PYGZus{}interface}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\end{Verbatim}
\index{bpms (DakotaInterface attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaInterface.bpms}\pysigline{\sphinxbfcode{bpms}}
\end{fulllineitems}

\index{driver (DakotaInterface attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaInterface.driver}\pysigline{\sphinxbfcode{driver}}
\end{fulllineitems}

\index{get\_config() (DakotaInterface method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaInterface.get_config}\pysiglinewithargsret{\sphinxbfcode{get\_config}}{\emph{rtype='list'}}{}
get interface configuration for dakota input block
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{rtype}} -- `list' or `string'

\item[{Returns}] \leavevmode
dakota interface input

\end{description}\end{quote}

\end{fulllineitems}

\index{hcors (DakotaInterface attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaInterface.hcors}\pysigline{\sphinxbfcode{hcors}}
\end{fulllineitems}

\index{latfile (DakotaInterface attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaInterface.latfile}\pysigline{\sphinxbfcode{latfile}}
\end{fulllineitems}

\index{mode (DakotaInterface attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaInterface.mode}\pysigline{\sphinxbfcode{mode}}
\end{fulllineitems}

\index{ref\_flag (DakotaInterface attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaInterface.ref_flag}\pysigline{\sphinxbfcode{ref\_flag}}
\end{fulllineitems}

\index{ref\_x0 (DakotaInterface attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaInterface.ref_x0}\pysigline{\sphinxbfcode{ref\_x0}}
\end{fulllineitems}

\index{ref\_y0 (DakotaInterface attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaInterface.ref_y0}\pysigline{\sphinxbfcode{ref\_y0}}
\end{fulllineitems}

\index{set\_extra() (DakotaInterface method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaInterface.set_extra}\pysiglinewithargsret{\sphinxbfcode{set\_extra}}{\emph{**kws}}{}
add extra configurations

\end{fulllineitems}

\index{vcors (DakotaInterface attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaInterface.vcors}\pysigline{\sphinxbfcode{vcors}}
\end{fulllineitems}


\end{fulllineitems}

\index{DakotaMethod (class in genopt.dakutils)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaMethod}\pysiglinewithargsret{\sphinxstrong{class }\sphinxbfcode{DakotaMethod}}{\emph{method='cg'}, \emph{iternum=20}, \emph{tolerance=0.0001}, \emph{**kws}}{}
Bases: \href{https://docs.python.org/2/library/functions.html\#object}{\sphinxcode{object}}

create dakota method for \sphinxcode{method} block
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{method}} -- method name, `cg' by default, all possible choices: `cg', `ps'

\item {} 
\textbf{\texttt{iternum}} -- max iteration number, 20 by default

\item {} 
\textbf{\texttt{tolerance}} -- convergence tolerance, 1e-4 by default

\item {} 
\textbf{\texttt{kws}} -- other keyword parameters

\end{itemize}

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} default}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}method} \PYG{o}{=} \PYG{n}{DakotaMethod}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{oc\PYGZus{}method}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}conmin\PYGZus{}frcg\PYGZsq{}, \PYGZsq{} convergence\PYGZus{}tolerance 0.0001\PYGZsq{}, \PYGZsq{} max\PYGZus{}iterations 20\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} define method with pattern search}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}method} \PYG{o}{=} \PYG{n}{DakotaMethod}\PYG{p}{(}\PYG{n}{method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ps}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{oc\PYGZus{}method}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}coliny\PYGZus{}pattern\PYGZus{}search\PYGZsq{}, \PYGZsq{} contraction\PYGZus{}factor 0.75\PYGZsq{}, \PYGZsq{} max\PYGZus{}function\PYGZus{}evaluations 500\PYGZsq{}, }
\PYG{g+go}{ \PYGZsq{} solution\PYGZus{}accuracy 0.0001\PYGZsq{}, \PYGZsq{} exploratory\PYGZus{}moves basic\PYGZus{}pattern\PYGZsq{}, }
\PYG{g+go}{ \PYGZsq{} threshold\PYGZus{}delta 0.0001\PYGZsq{}, \PYGZsq{} initial\PYGZus{}delta 0.5\PYGZsq{}, \PYGZsq{} max\PYGZus{}iterations 100\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} modify options of pattern search method}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}method} \PYG{o}{=} \PYG{n}{DakotaMethod}\PYG{p}{(}\PYG{n}{method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ps}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{max\PYGZus{}iterations}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{contraction\PYGZus{}factor}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{oc\PYGZus{}method}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}coliny\PYGZus{}pattern\PYGZus{}search\PYGZsq{}, \PYGZsq{} contraction\PYGZus{}factor 0.8\PYGZsq{}, \PYGZsq{} max\PYGZus{}function\PYGZus{}evaluations 500\PYGZsq{}, }
\PYG{g+go}{ \PYGZsq{} solution\PYGZus{}accuracy 0.0001\PYGZsq{}, \PYGZsq{} exploratory\PYGZus{}moves basic\PYGZus{}pattern\PYGZsq{}, }
\PYG{g+go}{ \PYGZsq{} threshold\PYGZus{}delta 0.0001\PYGZsq{}, \PYGZsq{} initial\PYGZus{}delta 0.5\PYGZsq{}, \PYGZsq{} max\PYGZus{}iterations 200\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} conmin\PYGZus{}frcg method}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}method} \PYG{o}{=} \PYG{n}{DakotaMethod}\PYG{p}{(}\PYG{n}{method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{oc\PYGZus{}method}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}conmin\PYGZus{}frcg\PYGZsq{}, \PYGZsq{} convergence\PYGZus{}tolerance 0.0001\PYGZsq{}, \PYGZsq{} max\PYGZus{}iterations 20\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} modify options}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}method} \PYG{o}{=} \PYG{n}{DakotaMethod}\PYG{p}{(}\PYG{n}{method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{max\PYGZus{}iterations}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{oc\PYGZus{}method}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}conmin\PYGZus{}frcg\PYGZsq{}, \PYGZsq{} convergence\PYGZus{}tolerance 0.0001\PYGZsq{}, \PYGZsq{} max\PYGZus{}iterations 100\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\end{Verbatim}
\index{get\_config() (DakotaMethod method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaMethod.get_config}\pysiglinewithargsret{\sphinxbfcode{get\_config}}{\emph{rtype='list'}}{}
get method configuration for dakota input block
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{rtype}} -- `list' or `string'

\item[{Returns}] \leavevmode
dakota method input

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_default\_method() (DakotaMethod method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaMethod.get_default_method}\pysiglinewithargsret{\sphinxbfcode{get\_default\_method}}{\emph{method}}{}
get default configuration of some method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{method}} -- method name, `cg' or `ps'

\item[{Returns}] \leavevmode
dict of configuration

\end{description}\end{quote}

\end{fulllineitems}

\index{method() (DakotaMethod method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaMethod.method}\pysiglinewithargsret{\sphinxbfcode{method}}{\emph{method}}{}
return method configuration
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{method}} -- method stirng name, `cg' or `ps'

\item[{Returns}] \leavevmode
list of method configuration

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{DakotaModel (class in genopt.dakutils)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaModel}\pysiglinewithargsret{\sphinxstrong{class }\sphinxbfcode{DakotaModel}}{\emph{**kws}}{}
Bases: \href{https://docs.python.org/2/library/functions.html\#object}{\sphinxcode{object}}

create dakota model for \sphinxcode{model} block
\index{get\_config() (DakotaModel method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaModel.get_config}\pysiglinewithargsret{\sphinxbfcode{get\_config}}{\emph{rtype='list'}}{}
get model configuration for dakota input block
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{rtype}} -- `list' or `string'

\item[{Returns}] \leavevmode
dakota model input

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{DakotaParam (class in genopt.dakutils)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaParam}\pysiglinewithargsret{\sphinxstrong{class }\sphinxbfcode{DakotaParam}}{\emph{label}, \emph{initial=0.0}, \emph{lower=-10000000000.0}, \emph{upper=10000000000.0}}{}
Bases: \href{https://docs.python.org/2/library/functions.html\#object}{\sphinxcode{object}}

create dakota variable for \sphinxcode{variables} block
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{label}} -- string to represent itself, e.g. \sphinxcode{x001},
it is recommended to annotate the number with the format of \sphinxcode{\%03d},
i.e. \sphinxcode{1 -{-}\textgreater{} 001}, \sphinxcode{10 -{-}\textgreater{} 010}, \sphinxcode{100 -{-}\textgreater{} 100}, etc.

\item {} 
\textbf{\texttt{initial}} -- initial value, 0.0 by default

\item {} 
\textbf{\texttt{lower}} -- lower bound, -1.0e10 by default

\item {} 
\textbf{\texttt{upper}} -- upper bound, 1.0e10 by default

\end{itemize}

\end{description}\end{quote}
\index{initial (DakotaParam attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaParam.initial}\pysigline{\sphinxbfcode{initial}}
\end{fulllineitems}

\index{label (DakotaParam attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaParam.label}\pysigline{\sphinxbfcode{label}}
\end{fulllineitems}

\index{lower (DakotaParam attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaParam.lower}\pysigline{\sphinxbfcode{lower}}
\end{fulllineitems}

\index{upper (DakotaParam attribute)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaParam.upper}\pysigline{\sphinxbfcode{upper}}
\end{fulllineitems}


\end{fulllineitems}

\index{DakotaResponses (class in genopt.dakutils)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaResponses}\pysiglinewithargsret{\sphinxstrong{class }\sphinxbfcode{DakotaResponses}}{\emph{nfunc=1}, \emph{gradient=None}, \emph{hessian=None}, \emph{**kws}}{}
Bases: \href{https://docs.python.org/2/library/functions.html\#object}{\sphinxcode{object}}

create dakota responses for \sphinxcode{responses} block
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{nfunc}} -- num of objective functions

\item {} 
\textbf{\texttt{gradient}} -- gradient type: `analytic' or `numerical'

\item {} 
\textbf{\texttt{hessian}} -- hessian configuration

\item {} 
\textbf{\texttt{kws}} -- keyword parameters for gradients and hessians
valid keys: any available for responses
among which key name of `grad' is for gradients configuration, 
the value should be a dict (future)

\end{itemize}

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} default responses:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{response} \PYG{o}{=} \PYG{n}{DakotaResponses}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{response}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}num\PYGZus{}objective\PYGZus{}functions = 1\PYGZsq{}, \PYGZsq{}no\PYGZus{}gradients\PYGZsq{}, \PYGZsq{}no\PYGZus{}hessians\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} responses with analytic gradients:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{response} \PYG{o}{=} \PYG{n}{DakotaResponses}\PYG{p}{(}\PYG{n}{gradient}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{analytic}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{response}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}num\PYGZus{}objective\PYGZus{}functions = 1\PYGZsq{}, \PYGZsq{}analytic\PYGZus{}gradients\PYGZsq{}, \PYGZsq{}no\PYGZus{}hessians\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} responses with numerical gradients, default configuration:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}responses} \PYG{o}{=} \PYG{n}{DakotaResponses}\PYG{p}{(}\PYG{n}{gradient}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{numerical}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{oc\PYGZus{}responses}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}num\PYGZus{}objective\PYGZus{}functions = 1\PYGZsq{}, \PYGZsq{}numerical\PYGZus{}gradients\PYGZsq{}, \PYGZsq{} method\PYGZus{}source dakota\PYGZsq{}, }
\PYG{g+go}{ \PYGZsq{} interval\PYGZus{}type forward\PYGZsq{}, \PYGZsq{} fd\PYGZus{}gradient\PYGZus{}step\PYGZus{}size 1e\PYGZhy{}06\PYGZsq{}, \PYGZsq{}no\PYGZus{}hessians\PYGZsq{}]}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} responses with numerical gradients, define step:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}responses} \PYG{o}{=} \PYG{n}{DakotaResponses}\PYG{p}{(}\PYG{n}{gradient}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{numerical}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{step}\PYG{o}{=}\PYG{l+m+mf}{2.0e\PYGZhy{}7}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{oc\PYGZus{}responses}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}num\PYGZus{}objective\PYGZus{}functions = 1\PYGZsq{}, \PYGZsq{}numerical\PYGZus{}gradients\PYGZsq{}, \PYGZsq{} method\PYGZus{}source dakota\PYGZsq{}, }
\PYG{g+go}{ \PYGZsq{} interval\PYGZus{}type forward\PYGZsq{}, \PYGZsq{} fd\PYGZus{}gradient\PYGZus{}step\PYGZus{}size 2e\PYGZhy{}07\PYGZsq{}, \PYGZsq{}no\PYGZus{}hessians\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} given other keyword parameters:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oc\PYGZus{}responses} \PYG{o}{=} \PYG{n}{DakotaResponses}\PYG{p}{(}\PYG{n}{gradient}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{numerical}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{step}\PYG{o}{=}\PYG{l+m+mf}{2.0e\PYGZhy{}7}\PYG{p}{,} \PYG{n}{k1}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{k2}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{oc\PYGZus{}responses}\PYG{o}{.}\PYG{n}{get\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}num\PYGZus{}objective\PYGZus{}functions = 1\PYGZsq{}, \PYGZsq{}numerical\PYGZus{}gradients\PYGZsq{}, \PYGZsq{} method\PYGZus{}source dakota\PYGZsq{}, }
\PYG{g+go}{ \PYGZsq{} interval\PYGZus{}type forward\PYGZsq{}, \PYGZsq{} fd\PYGZus{}gradient\PYGZus{}step\PYGZus{}size 2e\PYGZhy{}07\PYGZsq{}, \PYGZsq{}no\PYGZus{}hessians\PYGZsq{}, \PYGZsq{}k2 = v2\PYGZsq{}, \PYGZsq{}k1 = v1\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\end{Verbatim}
\index{get\_config() (DakotaResponses method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaResponses.get_config}\pysiglinewithargsret{\sphinxbfcode{get\_config}}{\emph{rtype='list'}}{}
get responses configuration for dakota input block
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{rtype}} -- `list' or `string'

\item[{Returns}] \leavevmode
dakota responses input

\end{description}\end{quote}

\end{fulllineitems}

\index{gradients() (DakotaResponses method)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.DakotaResponses.gradients}\pysiglinewithargsret{\sphinxbfcode{gradients}}{\emph{type=None}, \emph{step=1e-06}, \emph{**kws}}{}
generate gradients configuration
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{type}} -- `numerical' or `analytic' (default)

\item {} 
\textbf{\texttt{step}} -- gradient step size, only valid when type is numerical

\item {} 
\textbf{\texttt{kws}} -- other keyword parameters

\end{itemize}

\item[{Returns}] \leavevmode
list of configuration

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{generate\_latfile() (in module genopt.dakutils)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.generate_latfile}\pysiglinewithargsret{\sphinxbfcode{generate\_latfile}}{\emph{machine}, \emph{latfile='out.lat'}}{}
Generate lattice file for the usage of FLAME code
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{machine}} -- flame machine object

\item {} 
\textbf{\texttt{latfile}} -- file name for generated lattice file, `out.lat' by default

\end{itemize}

\item[{Returns}] \leavevmode
None if failed to generate lattice file, or the out file name

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{flame} \PYG{k}{import} \PYG{n}{Machine}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{latfile} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test.lat}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{m} \PYG{o}{=} \PYG{n}{Machine}\PYG{p}{(}\PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{latfile}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{outfile1} \PYG{o}{=} \PYG{n}{generate\PYGZus{}latfile}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{out1.lat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{m}\PYG{o}{.}\PYG{n}{reconfigure}\PYG{p}{(}\PYG{l+m+mi}{80}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{theta\PYGZus{}x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{0.1}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{outfile2} \PYG{o}{=} \PYG{n}{generate\PYGZus{}latfile}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{out2.lat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\end{Verbatim}

\begin{notice}{warning}{Warning:}
To get element configuration only by \sphinxcode{m.conf(i)} method,
where \sphinxcode{m} is \sphinxcode{flame.Machine} object, \sphinxcode{i} is element index,
when some re-configuring operation is done, \sphinxcode{m.conf(i)} will be update,
but \sphinxcode{m.conf(){[}"elements"{]}} remains with the initial value.
\end{notice}

\end{fulllineitems}

\index{get\_opt\_results() (in module genopt.dakutils)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.get_opt_results}\pysiglinewithargsret{\sphinxbfcode{get\_opt\_results}}{\emph{outfile='dakota.out'}, \emph{rtype='dict'}}{}
extract optimized results from dakota output
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{outfile}} -- file name of dakota output file, 
`dakota.out' by default

\item {} 
\textbf{\texttt{rtype}} -- type of returned results, `dict' or `list', 
`dict' by default

\end{itemize}

\item[{Returns}] \leavevmode
by default return a dict of optimized results with each item
of the format like ``x1'':0.1, etc., or if rtype='list', return a 
list of values, when the keys are ascend sorted.

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt\PYGZus{}vars} \PYG{o}{=} \PYG{n}{get\PYGZus{}opt\PYGZus{}results}\PYG{p}{(}\PYG{n}{outfile}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{flame\PYGZus{}oc.out}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{rtype}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dict}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{opt\PYGZus{}vars}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}x2\PYGZsq{}: 0.0020782814353, \PYGZsq{}x1\PYGZsq{}: \PYGZhy{}0.0017913264033\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt\PYGZus{}vars} \PYG{o}{=} \PYG{n}{get\PYGZus{}opt\PYGZus{}results}\PYG{p}{(}\PYG{n}{outfile}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{flame\PYGZus{}oc.out}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{rtype}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{list}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{opt\PYGZus{}vars}\PYG{p}{)}
\PYG{g+go}{[\PYGZhy{}0.0017913264033, 0.0020782814353]}
\end{Verbatim}

\end{fulllineitems}

\index{random\_string() (in module genopt.dakutils)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.random_string}\pysiglinewithargsret{\sphinxbfcode{random\_string}}{\emph{length=8}}{}
generate random string with given length
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{length}} -- string length, 8 by default

\item[{Returns}] \leavevmode
random strings with defined length

\end{description}\end{quote}

\end{fulllineitems}

\index{test\_dakotaenviron() (in module genopt.dakutils)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.test_dakotaenviron}\pysiglinewithargsret{\sphinxbfcode{test\_dakotaenviron}}{}{}
\end{fulllineitems}

\index{test\_dakotainput() (in module genopt.dakutils)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.test_dakotainput}\pysiglinewithargsret{\sphinxbfcode{test\_dakotainput}}{}{}
\end{fulllineitems}

\index{test\_dakotainterface() (in module genopt.dakutils)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.test_dakotainterface}\pysiglinewithargsret{\sphinxbfcode{test\_dakotainterface}}{}{}
\end{fulllineitems}

\index{test\_dakotamethod() (in module genopt.dakutils)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.test_dakotamethod}\pysiglinewithargsret{\sphinxbfcode{test\_dakotamethod}}{}{}
\end{fulllineitems}

\index{test\_dakotamodel() (in module genopt.dakutils)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.test_dakotamodel}\pysiglinewithargsret{\sphinxbfcode{test\_dakotamodel}}{}{}
\end{fulllineitems}

\index{test\_dakotaparam() (in module genopt.dakutils)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.test_dakotaparam}\pysiglinewithargsret{\sphinxbfcode{test\_dakotaparam}}{}{}
\end{fulllineitems}

\index{test\_dakotaresponses() (in module genopt.dakutils)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.test_dakotaresponses}\pysiglinewithargsret{\sphinxbfcode{test\_dakotaresponses}}{}{}
\end{fulllineitems}

\index{test\_get\_opt\_results() (in module genopt.dakutils)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.test_get_opt_results}\pysiglinewithargsret{\sphinxbfcode{test\_get\_opt\_results}}{}{}
\end{fulllineitems}

\index{test\_one\_element() (in module genopt.dakutils)}

\begin{fulllineitems}
\phantomsection\label{src/apidocs/dakutils:genopt.dakutils.test_one_element}\pysiglinewithargsret{\sphinxbfcode{test\_one\_element}}{\emph{x}}{}
test if all the elements are the same
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{x}} -- list, tuple, or numpy array

\item[{Returns}] \leavevmode
True if all are the same, else False

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{g}
\item {\texttt{genopt}}, \pageref{src/apidocs/genopt:module-genopt}
\item {\texttt{genopt.dakopt}}, \pageref{src/apidocs/dakopt:module-genopt.dakopt}
\item {\texttt{genopt.dakutils}}, \pageref{src/apidocs/dakutils:module-genopt.dakutils}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
